<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>noahyzhang&#39;s blog</title>
  
  
  <link href="https://noahyzhang.github.io/atom.xml" rel="self"/>
  
  <link href="https://noahyzhang.github.io/"/>
  <updated>2023-11-26T09:32:44.958Z</updated>
  <id>https://noahyzhang.github.io/</id>
  
  <author>
    <name>noahyzhang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>memcache 使用</title>
    <link href="https://noahyzhang.github.io/2023/11/26/%E7%BB%84%E4%BB%B6%E5%AD%A6%E4%B9%A0/memcache/memcache%E4%BD%BF%E7%94%A8/"/>
    <id>https://noahyzhang.github.io/2023/11/26/%E7%BB%84%E4%BB%B6%E5%AD%A6%E4%B9%A0/memcache/memcache%E4%BD%BF%E7%94%A8/</id>
    <published>2023-11-26T02:28:04.487Z</published>
    <updated>2023-11-26T09:32:44.958Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、安装和运行"><a href="#一、安装和运行" class="headerlink" title="一、安装和运行"></a>一、安装和运行</h3><p>memcache 安装</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install libevent libevent-dev</span><br><span class="line">sudo apt install memcached</span><br></pre></td></tr></table></figure><p>memcache 帮助</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">memcached -h</span><br><span class="line">-d 启动一个守护进程</span><br><span class="line">-m 分配给 memcache 使用的内存数量，单位是 MB</span><br><span class="line">-u 运行 memcache 的用户</span><br><span class="line">-l 监听的服务器 IP 地址，可以有多个地址</span><br><span class="line">-p 设置 memcache 监听的端口</span><br><span class="line">-c 最大运行的并发连接数，默认是 1024</span><br><span class="line">-P 设置保存 memcache 的 pid 文件</span><br><span class="line">-v 打印错误/警告日志</span><br><span class="line">-vv 或 -vvv 打印更加详细的日志</span><br></pre></td></tr></table></figure><p>memcache 运行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 作为前台程序运行</span><br><span class="line">memcached -p 11211 -m 64m -vv</span><br><span class="line"># 作为后台程序运行</span><br><span class="line">memcached -p 11211 -m 64m -u root -l 192.168.0.200 -c 256 -P /tmp/memcached.pid -d</span><br></pre></td></tr></table></figure><p>使用 telnet 连接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">telnet HOST PORT</span><br><span class="line"></span><br><span class="line"># telnet 127.0.0.1 11211</span><br><span class="line">Trying 127.0.0.1...</span><br><span class="line">Connected to 127.0.0.1.</span><br><span class="line">Escape character is &#x27;^]&#x27;.</span><br><span class="line">^]</span><br><span class="line"></span><br><span class="line">telnet&gt;</span><br><span class="line">set foo 0 0 3</span><br><span class="line">bar</span><br><span class="line">STORED</span><br><span class="line">get foo</span><br><span class="line">VALUE foo 0 3</span><br><span class="line">bar</span><br><span class="line">END</span><br><span class="line">quit</span><br><span class="line">Connection closed by foreign host.</span><br></pre></td></tr></table></figure><h3 id="二、存储命令"><a href="#二、存储命令" class="headerlink" title="二、存储命令"></a>二、存储命令</h3><h4 id="1-set-命令"><a href="#1-set-命令" class="headerlink" title="1. set 命令"></a>1. set 命令</h4><p>如果 set 的 key 已经存在，该命令可以更新该 key 所对应的原来的数据。语法格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set key flags exptime bytes [noreply]</span><br></pre></td></tr></table></figure><ul><li>key：键值 key-value 结构中的 key，用于查找缓存值</li><li>flags：可以包含键值对的整形参数，客户机使用它存储关于键值对的额外信息</li><li>exptime：在缓存中保持键值对的时间长度（以秒为单位，0 表示永远）</li><li>bytes：在缓存中存储的字节数</li><li>noreply（可选）：该参数告知服务器不需要返回数据</li><li>value 存储的值（始终位于第二行），也就是 key-value 结构中的 value</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># key 为 foo</span><br><span class="line"># flags 为 0</span><br><span class="line"># exptime 为 900 秒</span><br><span class="line"># bytes 为 11 字节</span><br><span class="line"># value 为 hello_world</span><br><span class="line"></span><br><span class="line">set foo 0 900 11 </span><br><span class="line">hello_world</span><br></pre></td></tr></table></figure><p>如果数据设置成功，则输出：STORED；失败则输出 ERROR</p><h4 id="2-add-命令"><a href="#2-add-命令" class="headerlink" title="2. add 命令"></a>2. add 命令</h4><p>将 value 存储在指定的 key 中，如果 key 已经存在，则不会更新数据（过期的 key 会更新），之前的值将仍然保持相同，并且响应 NOT_STORED</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">add key flags exptime bytes [noreply]</span><br><span class="line">value</span><br></pre></td></tr></table></figure><p>参数含义、输出信息和 set 命令一致</p><h4 id="3-replace-命令"><a href="#3-replace-命令" class="headerlink" title="3. replace 命令"></a>3. replace 命令</h4><p>用于替换已经存在的 key 的 value。如果 key 不存在，则替换失败，并且响应 NOT_STORED</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">replace key flags exptime bytes [noreply]</span><br><span class="line">value</span><br></pre></td></tr></table></figure><p>参数含义、输出信息和 set 命令一致</p><h4 id="4-append-命令"><a href="#4-append-命令" class="headerlink" title="4. append 命令"></a>4. append 命令</h4><p>用于向已经存在的 key 的 value 后面追加数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">append key flags exptime bytes [noreply]</span><br><span class="line">value</span><br></pre></td></tr></table></figure><p>例子如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># set root 0 900 9</span><br><span class="line">memcached</span><br><span class="line">STORED</span><br><span class="line"># append root 0 900 6</span><br><span class="line">_redis</span><br><span class="line">STORED</span><br><span class="line"># get root</span><br><span class="line">VALUE root 0 15</span><br><span class="line">memcached_redis</span><br><span class="line">END</span><br></pre></td></tr></table></figure><p>输出信息：</p><ul><li>STORED：保存成功后输出</li><li>NOT_STORED：该键在 memcached 上不存在</li><li>CLIENT_ERROR：执行错误</li></ul><h4 id="5-prepend-命令"><a href="#5-prepend-命令" class="headerlink" title="5. prepend 命令"></a>5. prepend 命令</h4><p>用于向已经存在的 key 的 value 前面追加数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">prepend key flags exptime bytes [noreply]</span><br><span class="line">value</span><br></pre></td></tr></table></figure><p>输出信息和 append 命令一致</p><h4 id="6-CAS-命令"><a href="#6-CAS-命令" class="headerlink" title="6. CAS 命令"></a>6. CAS 命令</h4><p>CAS（check-and-set 或 compare-and-swap）命令用于执行一个 “检查并设置” 的操作。</p><p>他仅在当前客户端最后一次取值后，该 key 对应的值没有被其他客户端修改的情况下，才能够将值写入。检查是通过 cas_token 参数进行的，这个参数是 memcached 指定给已经存在的元素的唯一的 64 位值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cas key flags exptime bytes unique_cas_token [noreply]</span><br><span class="line">value</span><br></pre></td></tr></table></figure><ul><li>unique_cas_token：通过 gets 命令获取的一个唯一的 64 位值</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># set root 0 900 9</span><br><span class="line">memcached</span><br><span class="line">STORED</span><br><span class="line"></span><br><span class="line"># gets root</span><br><span class="line">VALUE root 0 9 7</span><br><span class="line">memcached</span><br><span class="line">END</span><br><span class="line"></span><br><span class="line"># cas root 0 900 5 7</span><br><span class="line">redis</span><br><span class="line">STORED</span><br><span class="line"></span><br><span class="line"># get root</span><br><span class="line">VALUE root 0 5</span><br><span class="line">redis</span><br><span class="line">END</span><br></pre></td></tr></table></figure><p>输出信息包括：</p><ul><li>STORED：保存成功后输出</li><li>ERROR：保存出错或语法错误</li><li>EXISTS：在最后一次取值后另外一个用户也在更新该数据</li><li>NOT_FOUND：memcached 服务器上不存在该键值</li></ul><h3 id="三、查找-删除命令"><a href="#三、查找-删除命令" class="headerlink" title="三、查找&#x2F;删除命令"></a>三、查找&#x2F;删除命令</h3><h4 id="1-get-命令"><a href="#1-get-命令" class="headerlink" title="1. get 命令"></a>1. get 命令</h4><p>获取存储在 key 中的 value，如果 key 不存在，则返回空</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">get key</span><br><span class="line"># 多个 key，使用空格分开</span><br><span class="line">get key1 key2 key3</span><br></pre></td></tr></table></figure><h4 id="2-gets-命令"><a href="#2-gets-命令" class="headerlink" title="2. gets 命令"></a>2. gets 命令</h4><p>获取带有 CAS 令牌存储的 value，如果 key 不存在，则返回空</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gets key</span><br><span class="line"># 多个 key，使用空格分开</span><br><span class="line">gets key1 key2 key3</span><br></pre></td></tr></table></figure><p>如下例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gets root</span><br><span class="line">VALUE root 0 9 7    # 这里的 7 就代表 key=root 的 CAS 令牌</span><br><span class="line">memcached</span><br><span class="line">END</span><br></pre></td></tr></table></figure><h4 id="3-incr-decr-命令"><a href="#3-incr-decr-命令" class="headerlink" title="3. incr&#x2F;decr 命令"></a>3. incr&#x2F;decr 命令</h4><p>用于对已经存在的 key 的数字值进行自增或自减操作。incr 和 decr 命令<strong>操作的数据必须是十进制的 32 位无符号整数</strong>。</p><p>decr 减到 0 之后，在执行 decr 不会为负数，还为 0。incr 增加的值如果超过一定值后，则会报错。</p><p>如果 key 不存在返回 NOT_FOUND，如果键的值不为数字，则返回 CLIENT_ERROR，其他错误返回 ERROR</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">incr key increment_value</span><br><span class="line">decr key decrement_value</span><br></pre></td></tr></table></figure><p>举例如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># set root 0 900 3</span><br><span class="line">001</span><br><span class="line">STORED</span><br><span class="line"></span><br><span class="line"># incr root 999999999999999999</span><br><span class="line">1000000000000000000</span><br><span class="line"></span><br><span class="line"># incr root 999999999999999999999999</span><br><span class="line">CLIENT_ERROR invalid numeric delta argument</span><br><span class="line"></span><br><span class="line"># get root</span><br><span class="line">VALUE root 0 19</span><br><span class="line">1000000000000000000</span><br><span class="line">END</span><br><span class="line"></span><br><span class="line"># decr root 999999999999999999999999999999</span><br><span class="line">CLIENT_ERROR invalid numeric delta argument</span><br><span class="line"></span><br><span class="line"># decr root 1000000000000000000</span><br><span class="line">0</span><br><span class="line"></span><br><span class="line"># decr root 99</span><br><span class="line">0</span><br></pre></td></tr></table></figure><h4 id="4-delete-命令"><a href="#4-delete-命令" class="headerlink" title="4. delete 命令"></a>4. delete 命令</h4><p>用于删除已经存在的 key</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete key [noreply]</span><br></pre></td></tr></table></figure><h4 id="5-flush-all-命令"><a href="#5-flush-all-命令" class="headerlink" title="5. flush_all 命令"></a>5. flush_all 命令</h4><p>用于清理所有键值对。该命令提供了一个可选参数 time，用于在指定的时间后执行清理缓存操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flush_all [time] [noreply]</span><br></pre></td></tr></table></figure><h3 id="四、统计命令"><a href="#四、统计命令" class="headerlink" title="四、统计命令"></a>四、统计命令</h3><p>stats 命令，以及子命令。</p><h3 id="五、操作"><a href="#五、操作" class="headerlink" title="五、操作"></a>五、操作</h3><p>使用 java 来连接 memcached 服务器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MemcachedJava</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 本地连接 Memcached 服务</span></span><br><span class="line">            <span class="type">MemcachedClient</span> <span class="variable">mcc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MemcachedClient</span>(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;192.168.61.130&quot;</span>, <span class="number">11211</span>));</span><br><span class="line">            System.out.println(<span class="string">&quot;Connection to server successful.&quot;</span>);</span><br><span class="line"></span><br><span class="line">            Future&lt;Boolean&gt; fo = mcc.set(<span class="string">&quot;root&quot;</span>, <span class="number">900</span>, <span class="string">&quot;Free Education&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;set status: &quot;</span> + fo.get());</span><br><span class="line">            System.out.println(<span class="string">&quot;root value in cache - &quot;</span> + mcc.get(<span class="string">&quot;root&quot;</span>));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 关闭连接</span></span><br><span class="line">            mcc.shutdown();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            System.out.println(ex.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;一、安装和运行&quot;&gt;&lt;a href=&quot;#一、安装和运行&quot; class=&quot;headerlink&quot; title=&quot;一、安装和运行&quot;&gt;&lt;/a&gt;一、安装和运行&lt;/h3&gt;&lt;p&gt;memcache 安装&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext</summary>
      
    
    
    
    <category term="组件学习" scheme="https://noahyzhang.github.io/categories/%E7%BB%84%E4%BB%B6%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="memcache" scheme="https://noahyzhang.github.io/categories/%E7%BB%84%E4%BB%B6%E5%AD%A6%E4%B9%A0/memcache/"/>
    
    
  </entry>
  
  <entry>
    <title>docker对于文件映射的支持</title>
    <link href="https://noahyzhang.github.io/2023/11/25/%E7%BB%84%E4%BB%B6%E5%AD%A6%E4%B9%A0/docker/%E9%87%8D%E9%9A%BE%E7%82%B9/docker%E5%AF%B9%E4%BA%8E%E6%96%87%E4%BB%B6%E6%98%A0%E5%B0%84%E7%9A%84%E6%94%AF%E6%8C%81/"/>
    <id>https://noahyzhang.github.io/2023/11/25/%E7%BB%84%E4%BB%B6%E5%AD%A6%E4%B9%A0/docker/%E9%87%8D%E9%9A%BE%E7%82%B9/docker%E5%AF%B9%E4%BA%8E%E6%96%87%E4%BB%B6%E6%98%A0%E5%B0%84%E7%9A%84%E6%94%AF%E6%8C%81/</id>
    <published>2023-11-25T11:19:51.047Z</published>
    <updated>2023-11-25T12:31:28.163Z</updated>
    
    <content type="html"><![CDATA[<p>文件映射相当于将一个磁盘文件映射到内存中，通过 mmap 的方式，后面我们读写此文件的时候，就可以通过读写内存来操作此文件。本文我们测试一下通过 mmap 映射磁盘文件到内存中，docker 对其的支持情况。</p><h3 id="一、提出问题"><a href="#一、提出问题" class="headerlink" title="一、提出问题"></a>一、提出问题</h3><ul><li>容器重启后，映射的文件是否可以保留</li><li>不同容器之间，容器与宿主机之间。文件是否可见</li></ul><p>第二个问题很好回答，我们都知道，对于不同的容器环境，文件系统已经做了隔离。宿主机和容器之间也是。</p><h3 id="二、测试验证"><a href="#二、测试验证" class="headerlink" title="二、测试验证"></a>二、测试验证</h3><p>我们先来写两个程序，分别将磁盘文件映射到内存中。一个程序用于创建磁盘文件并写入数据，另一个程序则读取数据。</p><p>mmap_wr.cpp 程序用来创建一个磁盘文件，并且写入数据。如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MMAP_SIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">mmap_wr</span><span class="params">(<span class="type">const</span> std::string&amp; str)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> fd = <span class="built_in">open</span>(<span class="string">&quot;./mmap.txt&quot;</span>, O_RDWR | O_CREAT, S_IRUSR | S_IWUSR);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;open mmap.txt failed, errno: &quot;</span> &lt;&lt; errno &lt;&lt; <span class="string">&quot; msg: &quot;</span> &lt;&lt; <span class="built_in">strerror</span>(errno) &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">lseek</span>(fd, <span class="number">500</span>, SEEK_CUR);</span><br><span class="line">    <span class="built_in">write</span>(fd, <span class="string">&quot;\0&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">lseek</span>(fd, <span class="number">0</span>, SEEK_SET);</span><br><span class="line">    <span class="type">char</span>* p_mmap;</span><br><span class="line">    p_mmap = (<span class="type">char</span>*)<span class="built_in">mmap</span>((<span class="type">void</span>*)p_mmap, MMAP_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (!p_mmap) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;mmap failed, errno: &quot;</span> &lt;&lt; errno &lt;&lt; <span class="string">&quot; msg: &quot;</span> &lt;&lt; <span class="built_in">strerror</span>(errno) &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MMAP_SIZE<span class="number">-1</span> &amp;&amp; i &lt; str.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        *(p_mmap++) = str[i];</span><br><span class="line">    &#125;</span><br><span class="line">    *p_mmap = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;place input param, example: ./mmap_wr hello_world&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span>* p_str = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">mmap_wr</span>(p_str) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;mmap write failed&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;mmap write success&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mmap_rd.cpp 程序，读取这个磁盘文件中的数据。如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MMAP_SIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">mmap_rd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> fd = <span class="built_in">open</span>(<span class="string">&quot;./mmap.txt&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;open failed, errno: &quot;</span> &lt;&lt; errno &lt;&lt; <span class="string">&quot; msg: &quot;</span> &lt;&lt; <span class="built_in">strerror</span>(errno) &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span>* p_mmap = (<span class="type">char</span>*)<span class="built_in">mmap</span>(p_mmap, MMAP_SIZE, PROT_READ, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (!p_mmap) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;mmap failed, errno: &quot;</span> &lt;&lt; errno &lt;&lt; <span class="string">&quot; msg: &quot;</span> &lt;&lt; <span class="built_in">strerror</span>(errno) &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">    <span class="type">char</span>* p_str = p_mmap;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MMAP_SIZE<span class="number">-1</span>; i++) &#123;</span><br><span class="line">        <span class="type">char</span> tmp = *(p_str + i);</span><br><span class="line">        <span class="keyword">if</span> (tmp == <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; tmp &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">mmap_rd</span>() &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;mmap read failed&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;mmap read success&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后写 dockerfile，构建 docker 环境</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu:22.04</span><br><span class="line">MAINTAINER noahyzhang&lt;13572252156.163.com&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">COPY ./mmap_wr /bin/</span><br><span class="line">COPY ./mmap_rd /bin/</span><br></pre></td></tr></table></figure><p>我们使用命令：<code>docker build -t &quot;mmap_test:v1&quot; ./</code> 来创建 docker 环境。</p><p>然后使用命令：<code>docker run -it &quot;mmap_test:v1&quot; /bin/bash</code>  进入 docker 环境。进行操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 创建文件，并且写入</span><br><span class="line">root@69082a45e066:/# mmap_wr nihao</span><br><span class="line">mmap write success</span><br><span class="line"></span><br><span class="line"># 查看创建的文件</span><br><span class="line">root@69082a45e066:/# ls -l mmap.txt </span><br><span class="line">-rw------- 1 root root 501 Nov 25 12:19 mmap.txt</span><br><span class="line"></span><br><span class="line"># 查看文件内容</span><br><span class="line">root@69082a45e066:/# cat mmap.txt </span><br><span class="line">nihao</span><br><span class="line"></span><br><span class="line"># 使用文件映射查看文件内容</span><br><span class="line">root@69082a45e066:/# mmap_rd </span><br><span class="line">n i h a o </span><br><span class="line">mmap read success</span><br></pre></td></tr></table></figure><p>至此，功能一切正常，我们再来看，容器重启前后，此文件是否还存在。</p><p>先执行 <code>docker stop</code> ，然后再执行 <code>docker start</code>。再来查看此文件 mmap.txt 是否存在。我们发现此文件还是存在的，并且内容也还保存着。</p><p>即说明：容器重启，通过 mmap 映射的磁盘文件还存在。</p><p>我们再来深究一下，我们在宿主机上进行查找：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># sudo find / -name &quot;mmap.txt&quot; 2&gt;/dev/null</span><br><span class="line">/var/snap/docker/common/var-lib-docker/overlay2/eead50e410dd90ba505590681d70f7de590f8437b1da22dfe6a644b33ffa56d4/diff/mmap.txt</span><br><span class="line">/var/snap/docker/common/var-lib-docker/overlay2/c1d0c7de6c69610bb0706859c46b9b526cdedf4d666c0f5721c6aad2750190fe/diff/mmap.txt</span><br></pre></td></tr></table></figure><p>我们发现此文件存储在容器的可写文件系统中，因此即使容器重启，该文件也不会被删除，而是作为容器文件系统的一部分。</p><h3 id="三、小结"><a href="#三、小结" class="headerlink" title="三、小结"></a>三、小结</h3><p>本文通过测试，我们得到这么几点结论</p><ul><li>容器的重启，mmap 映射的磁盘文件不会被删除</li><li>容器与容器、容器与宿主机之间，文件可以做到隔离，但非要在宿主机上找容器的文件，也能找到，不过没啥必要</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;文件映射相当于将一个磁盘文件映射到内存中，通过 mmap 的方式，后面我们读写此文件的时候，就可以通过读写内存来操作此文件。本文我们测试一下通过 mmap 映射磁盘文件到内存中，docker 对其的支持情况。&lt;/p&gt;
&lt;h3 id=&quot;一、提出问题&quot;&gt;&lt;a href=&quot;#一、</summary>
      
    
    
    
    <category term="组件学习" scheme="https://noahyzhang.github.io/categories/%E7%BB%84%E4%BB%B6%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="docker" scheme="https://noahyzhang.github.io/categories/%E7%BB%84%E4%BB%B6%E5%AD%A6%E4%B9%A0/docker/"/>
    
    <category term="重难点" scheme="https://noahyzhang.github.io/categories/%E7%BB%84%E4%BB%B6%E5%AD%A6%E4%B9%A0/docker/%E9%87%8D%E9%9A%BE%E7%82%B9/"/>
    
    
  </entry>
  
  <entry>
    <title>docker容器对共享内存的支持</title>
    <link href="https://noahyzhang.github.io/2023/11/25/%E7%BB%84%E4%BB%B6%E5%AD%A6%E4%B9%A0/docker/%E9%87%8D%E9%9A%BE%E7%82%B9/docker%E5%AF%B9%E4%BA%8E%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E7%9A%84%E6%94%AF%E6%8C%81/"/>
    <id>https://noahyzhang.github.io/2023/11/25/%E7%BB%84%E4%BB%B6%E5%AD%A6%E4%B9%A0/docker/%E9%87%8D%E9%9A%BE%E7%82%B9/docker%E5%AF%B9%E4%BA%8E%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E7%9A%84%E6%94%AF%E6%8C%81/</id>
    <published>2023-11-25T06:59:41.526Z</published>
    <updated>2023-11-25T10:43:19.300Z</updated>
    
    <content type="html"><![CDATA[<p>我们在物理机时代，对于进程间通信，我们会经常想到使用共享内存，因为可以做到一块共享内存可以做到被映射到多个进程的虚拟地址空间，从而实现进程间通信比较快速。并且进程退出后，共享内存还在，并不会归还给操作系统。这样在一定程序上做到了数据的持久性。</p><p>进入 docker 时代，程序的部署、发布一般都采用 k8s、docker 等这种云上技术，本文探讨一下 docker 容器对于共享内存的支持。</p><h3 id="一、提出问题"><a href="#一、提出问题" class="headerlink" title="一、提出问题"></a>一、提出问题</h3><ol><li>不同的容器之间，“共享内存” 是否隔离？</li><li>容器中创建的 “共享内存”，在宿主机中是否可见？</li><li>容器退出之后，“共享内存” 还能保持嘛？容器重启后，还能找到之前创建的 “共享内存” 嘛？</li></ol><p>我们怀抱着这些问题，先写 demo 进行测试</p><h3 id="二、测试验证"><a href="#二、测试验证" class="headerlink" title="二、测试验证"></a>二、测试验证</h3><h4 id="1-前提准备"><a href="#1-前提准备" class="headerlink" title="1. 前提准备"></a>1. 前提准备</h4><p>我们有一个程序 <code>shm_wr.cpp</code>，用于创建共享内存并且写共享内存。将一段字符串写入到共享内存中。如下展示</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys/shm.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHM_KEY 20231125</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHM_SIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">shm_wr</span><span class="params">(<span class="type">const</span> std::string&amp; write_str)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> shm_id = <span class="built_in">shmget</span>(SHM_KEY, SHM_SIZE, IPC_CREAT | <span class="number">0666</span>);</span><br><span class="line">    <span class="keyword">if</span> (shm_id &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;shmget failed, errno: &quot;</span> &lt;&lt; errno &lt;&lt; <span class="string">&quot; msg: &quot;</span> &lt;&lt; <span class="built_in">strerror</span>(errno) &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">void</span>* p_shm = <span class="built_in">shmat</span>(shm_id, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (p_shm == (<span class="type">void</span>*)<span class="number">-1</span>) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;shmat failed, errno: &quot;</span> &lt;&lt; errno &lt;&lt; <span class="string">&quot; msg: &quot;</span> &lt;&lt; <span class="built_in">strerror</span>(errno) &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span>* p_str = (<span class="type">char</span>*)p_shm;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; SHM_SIZE<span class="number">-1</span> &amp;&amp; i &lt; write_str.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        *p_str++ = write_str[i];</span><br><span class="line">    &#125;</span><br><span class="line">    *p_str = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;place input str, example: ./shm_wr abcd&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span>* p_str = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">shm_wr</span>(p_str) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;shm write failed&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;shm write success&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一段程序 <code>shm_rd.cpp</code>，我们用于从共享内存中读出数据，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys/shm.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHM_KEY 20231125</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHM_SIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">shm_rd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> shm_id = <span class="built_in">shmget</span>(SHM_KEY, SHM_SIZE, <span class="number">0666</span>);</span><br><span class="line">    <span class="keyword">if</span> (shm_id &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;shmget failed, errno: &quot;</span> &lt;&lt; errno &lt;&lt; <span class="string">&quot; msg: &quot;</span> &lt;&lt; <span class="built_in">strerror</span>(errno) &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">void</span>* p_shm = <span class="built_in">shmat</span>(shm_id, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (p_shm == (<span class="type">void</span>*)<span class="number">-1</span>) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;shmat failed, errno: &quot;</span> &lt;&lt; errno &lt;&lt; <span class="string">&quot; msg: &quot;</span> &lt;&lt; <span class="built_in">strerror</span>(errno) &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span>* p_str = (<span class="type">char</span>*)p_shm;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; SHM_SIZE<span class="number">-1</span>; i++) &#123;</span><br><span class="line">        <span class="type">char</span> tmp = *(p_str+i);</span><br><span class="line">        <span class="keyword">if</span> (tmp == <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; tmp &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">shm_rd</span>() &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;shm read failed&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;shm read success&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分别将这两个程序进行编译，得到两个二进制：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g++ shm_wr.cpp -g -o shm_wr</span><br><span class="line">g++ shm_rd.cpp -g -o shm_rd</span><br></pre></td></tr></table></figure><p>然后我们再构建 docker image。如下是 Dockerfile。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">22.04</span></span><br><span class="line"><span class="keyword">MAINTAINER</span> noahyzhang&lt;<span class="number">13572252156.163</span>.com&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./shm_wr /bin/</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./shm_rd /bin/</span></span><br></pre></td></tr></table></figure><p>接下来，使用 docker 命令：<code>docker build -t &quot;shm_test:v1&quot; ./</code> </p><p>得到 docker image。此时我们就可以开始实验了。</p><h4 id="2-测试实验"><a href="#2-测试实验" class="headerlink" title="2. 测试实验"></a>2. 测试实验</h4><p>我们首先启动一个 container A，观察现象。命令：<code>docker run -it &quot;shm_test:v1&quot; /bin/bash</code></p><p>然后在容器中，我们执行 shm_wr 这个二进制，创建共享内存，并且写入数据。命令：<code>shm_wr hello_world</code>。执行完此命令后，终端输出写入成功。然后我们在容器中查看共享内存是否创建。使用：<code>ipcs -m</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root@62e8cbc0e106:/# shm_wr hello_world</span><br><span class="line">shm write success</span><br><span class="line">root@62e8cbc0e106:/# ipcs -m</span><br><span class="line"></span><br><span class="line">------ Shared Memory Segments --------</span><br><span class="line">key        shmid      owner      perms      bytes      nattch     status      </span><br><span class="line">0x0134b3d5 0          root       666        1024       0                       </span><br></pre></td></tr></table></figure><p>我们看到共享内存创建成功。然后使用 shm_rd 去读取此共享内存。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@62e8cbc0e106:/# shm_rd</span><br><span class="line">h e l l o _ w o r l d </span><br><span class="line">shm read success</span><br></pre></td></tr></table></figure><p>到这里，我们验证了共享内存的正常使用。</p><h5 id="1-验证容器之间共享内存的隔离性"><a href="#1-验证容器之间共享内存的隔离性" class="headerlink" title="(1). 验证容器之间共享内存的隔离性"></a>(1). 验证容器之间共享内存的隔离性</h5><p>我们再启动一个 container B，命令依然是：<code>docker run -it &quot;shm_test:v1&quot; ./</code> </p><p>进入容器后，先看看是否存在共享内存。通过 ipcs 命令和 shm_rd 二进制查看。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">root@2c7572cba938:/# ipcs -m</span><br><span class="line"></span><br><span class="line">------ Shared Memory Segments --------</span><br><span class="line">key        shmid      owner      perms      bytes      nattch     status</span><br><span class="line"></span><br><span class="line">root@2c7572cba938:/# shm_rd</span><br><span class="line">shmget failed, errno: 2 msg: No such file or directory</span><br><span class="line">shm read failed</span><br></pre></td></tr></table></figure><p>发现并没有共享内存。然后在 container B 中，我们创建共享内存，并且写入数据。如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">root@2c7572cba938:/# shm_wr nihao</span><br><span class="line">shm write success</span><br><span class="line">root@2c7572cba938:/# shm_rd</span><br><span class="line">n i h a o</span><br><span class="line">shm read success</span><br><span class="line">root@2c7572cba938:/# ipcs -m</span><br><span class="line"></span><br><span class="line">------ Shared Memory Segments --------</span><br><span class="line">key        shmid      owner      perms      bytes      nattch     status</span><br><span class="line">0x0134b3d5 0          root       666        1024       0</span><br></pre></td></tr></table></figure><p>我们发现，容器 A 和 容器 B 的共享内存互相之间不可见。也就是说<strong>容器之间共享内存是隔离的</strong>。</p><h5 id="2-宿主机是否可以看到容器中创建的共享内存"><a href="#2-宿主机是否可以看到容器中创建的共享内存" class="headerlink" title="(2). 宿主机是否可以看到容器中创建的共享内存"></a>(2). 宿主机是否可以看到容器中创建的共享内存</h5><p>我们在宿主机中使用 ipcs 命令，或者 shm_rd 程序去读取共享内存。很明显，是读不到的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># ipcs -m</span><br><span class="line">------ Shared Memory Segments --------</span><br><span class="line">key        shmid      owner      perms      bytes      nattch     status</span><br><span class="line"></span><br><span class="line"># ./shm_rd</span><br><span class="line">shmget failed, errno: 2 msg: No such file or directory</span><br><span class="line">shm read failed</span><br></pre></td></tr></table></figure><p>说明<strong>容器中创建的共享内存对宿主机不可见</strong></p><h5 id="3-容器重启，共享内存是否还存在"><a href="#3-容器重启，共享内存是否还存在" class="headerlink" title="(3). 容器重启，共享内存是否还存在"></a>(3). 容器重启，共享内存是否还存在</h5><p>我们对容器进行重启。然后查看共享内存是否存在</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"># 查看当前处于运行中的容器</span><br><span class="line">$ docker ps</span><br><span class="line">CONTAINER ID   IMAGE          COMMAND       CREATED       STATUS       PORTS     NAMES</span><br><span class="line">2c7572cba938   b7fb738ad243   &quot;/bin/bash&quot;   2 hours ago   Up 2 hours             loving_curie</span><br><span class="line">62e8cbc0e106   b7fb738ad243   &quot;/bin/bash&quot;   2 hours ago   Up 2 hours             jovial_ganguly</span><br><span class="line"></span><br><span class="line"># 停止这两个容器</span><br><span class="line"># docker stop 2c7572cba938</span><br><span class="line">2c7572cba938</span><br><span class="line"># docker stop 62e8cbc0e106</span><br><span class="line">62e8cbc0e106</span><br><span class="line"></span><br><span class="line"># 开始这两个容器</span><br><span class="line"># docker start 2c7572cba938</span><br><span class="line">2c7572cba938</span><br><span class="line"># docker start 62e8cbc0e106</span><br><span class="line">62e8cbc0e106</span><br><span class="line"></span><br><span class="line"># 查看容器已经运行起来了</span><br><span class="line"># docker ps</span><br><span class="line">CONTAINER ID   IMAGE          COMMAND       CREATED       STATUS         PORTS     NAMES</span><br><span class="line">2c7572cba938   b7fb738ad243   &quot;/bin/bash&quot;   2 hours ago   Up 8 seconds             loving_curie</span><br><span class="line">62e8cbc0e106   b7fb738ad243   &quot;/bin/bash&quot;   2 hours ago   Up 2 seconds             jovial_ganguly</span><br><span class="line"></span><br><span class="line"># 链接容器</span><br><span class="line"># docker attach 2c7572cba938</span><br><span class="line"># 进入到了容器中了</span><br><span class="line">root@2c7572cba938:/# ipcs -m</span><br><span class="line">------ Shared Memory Segments --------</span><br><span class="line">key        shmid      owner      perms      bytes      nattch     status</span><br><span class="line"></span><br><span class="line">root@2c7572cba938:/# shm_rd</span><br><span class="line">shmget failed, errno: 2 msg: No such file or directory</span><br><span class="line">shm read failed</span><br></pre></td></tr></table></figure><p>此时我们发现重启后的容器已经没有这个共享内存的对象了。也就是说，当容器 stop 后，就相当于我们物理机关机，docker 将该容器对应的共享内存资源给清理的。<strong>容器重启后，之前创建的共享内存会被清理</strong>。</p><h3 id="三、小结"><a href="#三、小结" class="headerlink" title="三、小结"></a>三、小结</h3><p>同时，我们在以上的测试中。也发现，在不同的容器中，使用同一个 SHM_KEY，创建的共享内存的 key 是相同的，这是因为使用了相同的计算 key 的算法。如果在单个容器中，共享内存的 key 会保证唯一。</p><p>本文我们验证了 docker 对共享内存的支持。有三个结论：</p><ul><li>不同容器之间，共享内存是隔离的</li><li>容器与宿主机之间，共享内存是隔离的</li><li>容器重启后，之前创建的共享内存会被清理</li></ul><p>docker 是如何实现对共享内存的支持，我们后面再来对原理进行深究。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我们在物理机时代，对于进程间通信，我们会经常想到使用共享内存，因为可以做到一块共享内存可以做到被映射到多个进程的虚拟地址空间，从而实现进程间通信比较快速。并且进程退出后，共享内存还在，并不会归还给操作系统。这样在一定程序上做到了数据的持久性。&lt;/p&gt;
&lt;p&gt;进入 docke</summary>
      
    
    
    
    <category term="组件学习" scheme="https://noahyzhang.github.io/categories/%E7%BB%84%E4%BB%B6%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="docker" scheme="https://noahyzhang.github.io/categories/%E7%BB%84%E4%BB%B6%E5%AD%A6%E4%B9%A0/docker/"/>
    
    <category term="重难点" scheme="https://noahyzhang.github.io/categories/%E7%BB%84%E4%BB%B6%E5%AD%A6%E4%B9%A0/docker/%E9%87%8D%E9%9A%BE%E7%82%B9/"/>
    
    
  </entry>
  
  <entry>
    <title>CFS 算法在内核中的实现</title>
    <link href="https://noahyzhang.github.io/2023/11/23/%E9%A1%B9%E7%9B%AE/Linux%E7%A0%94%E7%A9%B6/CFS%E7%AE%97%E6%B3%95%E5%9C%A8%E5%86%85%E6%A0%B8%E4%B8%AD%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>https://noahyzhang.github.io/2023/11/23/%E9%A1%B9%E7%9B%AE/Linux%E7%A0%94%E7%A9%B6/CFS%E7%AE%97%E6%B3%95%E5%9C%A8%E5%86%85%E6%A0%B8%E4%B8%AD%E7%9A%84%E5%AE%9E%E7%8E%B0/</id>
    <published>2023-11-23T01:39:52.605Z</published>
    <updated>2023-11-23T01:42:30.970Z</updated>
    
    <content type="html"><![CDATA[<p>本文使用的内核版本为：<code>v2.6.12</code> </p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文使用的内核版本为：&lt;code&gt;v2.6.12&lt;/code&gt; &lt;/p&gt;
</summary>
      
    
    
    
    <category term="项目" scheme="https://noahyzhang.github.io/categories/%E9%A1%B9%E7%9B%AE/"/>
    
    <category term="Linux研究" scheme="https://noahyzhang.github.io/categories/%E9%A1%B9%E7%9B%AE/Linux%E7%A0%94%E7%A9%B6/"/>
    
    
  </entry>
  
  <entry>
    <title>内核数据结构之映射</title>
    <link href="https://noahyzhang.github.io/2023/11/13/%E9%A1%B9%E7%9B%AE/Linux%E7%A0%94%E7%A9%B6/%E5%86%85%E6%A0%B8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E6%98%A0%E5%B0%84/"/>
    <id>https://noahyzhang.github.io/2023/11/13/%E9%A1%B9%E7%9B%AE/Linux%E7%A0%94%E7%A9%B6/%E5%86%85%E6%A0%B8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E6%98%A0%E5%B0%84/</id>
    <published>2023-11-13T11:57:54.721Z</published>
    <updated>2023-11-13T12:49:50.757Z</updated>
    
    <content type="html"><![CDATA[<p>我们一般称键值对数组为映射，也称为哈希。一般查找的时间复杂度可以低至常数级别。在高频次的查询场景中，有较为优异的性能。关于映射的性质，我们不过多讨论，本文主要看看 Linux 中映射的实现，本文以 Linux 2.6.12 版本为例。</p><p>Linux 实现的映射，并不是一个通用的映射。他的目标是：映射一个唯一数（UID）到一个指针。</p><h3 id="一、实现结构"><a href="#一、实现结构" class="headerlink" title="一、实现结构"></a>一、实现结构</h3><p>Linux 提供了结构体 idr 用来完成这一目标。如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">idr_layer</span> &#123;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> bitmap;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">idr_layer</span>*<span class="title">ary</span>[1&lt;</span>&lt;IDR_BITS];  <span class="comment">// 64 位机器 IDR_BITS 为 6</span></span><br><span class="line"><span class="type">int</span> count;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">idr</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">idr_layer</span> *<span class="title">top</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">idr_layer</span> *<span class="title">id_free</span>;</span></span><br><span class="line"><span class="type">int</span>  layers;</span><br><span class="line"><span class="type">int</span>  id_free_cnt;</span><br><span class="line"><span class="type">spinlock_t</span>  lock;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>top：指向顶层（最高层），</li></ul><p>使用一些接口来构造一个 idr 数据结构，并进行初始化。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span>  <span class="type">int</span> <span class="title function_">init_id_cache</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!idr_layer_cache)</span><br><span class="line">idr_layer_cache = kmem_cache_create(<span class="string">&quot;idr_layer_cache&quot;</span>, </span><br><span class="line"><span class="keyword">sizeof</span>(<span class="keyword">struct</span> idr_layer), <span class="number">0</span>, <span class="number">0</span>, idr_cache_ctor, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">idr_init</span><span class="params">(<span class="keyword">struct</span> idr *idp)</span></span><br><span class="line">&#123;</span><br><span class="line">init_id_cache();</span><br><span class="line"><span class="built_in">memset</span>(idp, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> idr));</span><br><span class="line">spin_lock_init(&amp;idp-&gt;lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 idr_layer_cache 是一个全局变量，在初始化 idr 的时候，会尝试对 idr_layer_cache 进行初始化一次。暂时不用理 kmem_cache_create 方法的含义，只需要知道他是为 idr_layer_cache 获取到了内存空间即可。</p><p>然后将用户传入的 idr 结构体指针的空间，全部置为 0，并初始化结构体中的锁。</p><h3 id="二、分配一个-UID"><a href="#二、分配一个-UID" class="headerlink" title="二、分配一个 UID"></a>二、分配一个 UID</h3><p>构造好 idr 之后，就可以分配新的 UID 了。这个过程分为两步。</p><ul><li>告诉 idr，我们需要分配新的 UID，允许其在必要时可以调整后备树的大小</li><li>请求新的 UID</li></ul><p>对于第一步，我们可以使用 <code>idr_pre_get</code> 这个方法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">free_layer</span><span class="params">(<span class="keyword">struct</span> idr *idp, <span class="keyword">struct</span> idr_layer *p)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Depends on the return element being zeroed.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">spin_lock(&amp;idp-&gt;lock);</span><br><span class="line">p-&gt;ary[<span class="number">0</span>] = idp-&gt;id_free;</span><br><span class="line">idp-&gt;id_free = p;</span><br><span class="line">idp-&gt;id_free_cnt++;</span><br><span class="line">spin_unlock(&amp;idp-&gt;lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">idr_pre_get</span><span class="params">(<span class="keyword">struct</span> idr *idp, <span class="type">unsigned</span> gfp_mask)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (idp-&gt;id_free_cnt &lt; IDR_FREE_MAX) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">idr_layer</span> *<span class="title">new</span>;</span></span><br><span class="line">new = kmem_cache_alloc(idr_layer_cache, gfp_mask);</span><br><span class="line"><span class="keyword">if</span>(new == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line">free_layer(idp, new);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>IDR_FREE_MAX 这个值经过计算，在 64 位机器上是 12。感兴趣可以去计算一下。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我们一般称键值对数组为映射，也称为哈希。一般查找的时间复杂度可以低至常数级别。在高频次的查询场景中，有较为优异的性能。关于映射的性质，我们不过多讨论，本文主要看看 Linux 中映射的实现，本文以 Linux 2.6.12 版本为例。&lt;/p&gt;
&lt;p&gt;Linux 实现的映射，</summary>
      
    
    
    
    <category term="项目" scheme="https://noahyzhang.github.io/categories/%E9%A1%B9%E7%9B%AE/"/>
    
    <category term="Linux研究" scheme="https://noahyzhang.github.io/categories/%E9%A1%B9%E7%9B%AE/Linux%E7%A0%94%E7%A9%B6/"/>
    
    
  </entry>
  
  <entry>
    <title>内核数据结构之队列</title>
    <link href="https://noahyzhang.github.io/2023/11/12/%E9%A1%B9%E7%9B%AE/Linux%E7%A0%94%E7%A9%B6/%E5%86%85%E6%A0%B8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E9%98%9F%E5%88%97/"/>
    <id>https://noahyzhang.github.io/2023/11/12/%E9%A1%B9%E7%9B%AE/Linux%E7%A0%94%E7%A9%B6/%E5%86%85%E6%A0%B8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E9%98%9F%E5%88%97/</id>
    <published>2023-11-12T10:34:19.069Z</published>
    <updated>2023-11-13T02:18:37.720Z</updated>
    
    <content type="html"><![CDATA[<p>队列是一种定义了 FIFO 先进先出的结构。Linux 内核的队列实现在 <code>kfifo.c</code> 中。本文以 <code>Linux 2.6.12</code> 版本来进行讨论。</p><p>我们还是老样子，从底层实现看起，然后再来总结规律、适用场景。</p><h3 id="一、创建队列"><a href="#一、创建队列" class="headerlink" title="一、创建队列"></a>一、创建队列</h3><p>创建队列的实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> kfifo *<span class="title function_">kfifo_init</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *buffer, <span class="type">unsigned</span> <span class="type">int</span> size,</span></span><br><span class="line"><span class="params"> <span class="type">unsigned</span> <span class="type">int</span> __nocast gfp_mask, <span class="type">spinlock_t</span> *lock)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kfifo</span> *<span class="title">fifo</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* size must be a power of 2 */</span></span><br><span class="line">BUG_ON(size &amp; (size - <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">fifo = kmalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> kfifo), gfp_mask);</span><br><span class="line"><span class="keyword">if</span> (!fifo)</span><br><span class="line"><span class="keyword">return</span> ERR_PTR(-ENOMEM);</span><br><span class="line"></span><br><span class="line">fifo-&gt;buffer = buffer;</span><br><span class="line">fifo-&gt;size = size;</span><br><span class="line">fifo-&gt;in = fifo-&gt;out = <span class="number">0</span>;</span><br><span class="line">fifo-&gt;lock = lock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> fifo;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> kfifo *<span class="title function_">kfifo_alloc</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> size, <span class="type">unsigned</span> <span class="type">int</span> __nocast gfp_mask, <span class="type">spinlock_t</span> *lock)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *buffer;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kfifo</span> *<span class="title">ret</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * round up to the next power of 2, since our &#x27;let the indices</span></span><br><span class="line"><span class="comment"> * wrap&#x27; tachnique works only in this case.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (size &amp; (size - <span class="number">1</span>)) &#123;</span><br><span class="line">BUG_ON(size &gt; <span class="number">0x80000000</span>);</span><br><span class="line">size = roundup_pow_of_two(size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">buffer = kmalloc(size, gfp_mask);</span><br><span class="line"><span class="keyword">if</span> (!buffer)</span><br><span class="line"><span class="keyword">return</span> ERR_PTR(-ENOMEM);</span><br><span class="line"></span><br><span class="line">ret = kfifo_init(buffer, size, gfp_mask, lock);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (IS_ERR(ret))</span><br><span class="line">kfree(buffer);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建一个新的队列，并且初始化大小为 size。内核会使用 gfp_mask 标识分配队列，这是一个内存分配的标识。参数中还有一个锁。</p><p>首先将用户传入的 size 参数四舍五入到下一个 2 的幂。然后使用 kmalloc 分配 size 大小的空间，gfp_mask 暂时不用管。最后拿到申请出来的空间构造出来队列，如果构造成功，返回队列指针，如果构造失败，返回一个错误的指针。</p><p>如何构造队列呢？首先要保证 size 为 2 的幂，然后再给 kfifo 结构体给定内存空间，并初始化，即可返回。kfifo 结构体的定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kfifo</span> &#123;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *buffer;<span class="comment">/* the buffer holding the data */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> size;<span class="comment">/* the size of the allocated buffer */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> in;<span class="comment">/* data is added at offset (in % size) */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> out;<span class="comment">/* data is extracted from off. (out % size) */</span></span><br><span class="line"><span class="type">spinlock_t</span> *lock;<span class="comment">/* protects concurrent modifications */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>buffer 是数据的缓冲区</li><li>size 是已经申请的 buffer 的大小</li><li>in 是入口偏移。指的是下一次入队列时的位置</li><li>out 是出口偏移。指的是下一次出队列时的位置</li><li>lock 用于保护并发修改</li></ul><p>注意：出口偏移总是小于等于入口偏移，否则无意义，因为那样说明要出队列的元素根本还没有入队列。</p><p>话说回来，队列的创建历经了两次空间的申请。一次是申请 kfifo 队列结构体本身，另一次是申请数据缓存区。然后维护入口偏移和出口偏移。创建好的队列如下图所示：</p><img src="/2023/11/12/%E9%A1%B9%E7%9B%AE/Linux%E7%A0%94%E7%A9%B6/%E5%86%85%E6%A0%B8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E9%98%9F%E5%88%97/内核数据结构之队列1.png" style="zoom:50%;"><h3 id="二、进队列"><a href="#二、进队列" class="headerlink" title="二、进队列"></a>二、进队列</h3><p>插入元素到队列使用 <code>kfifo_put</code> 方法来实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">kfifo_put</span><span class="params">(<span class="keyword">struct</span> kfifo *fifo, <span class="type">unsigned</span> <span class="type">char</span> *buffer, <span class="type">unsigned</span> <span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">spin_lock_irqsave(fifo-&gt;lock, flags);</span><br><span class="line"></span><br><span class="line">ret = __kfifo_put(fifo, buffer, len);</span><br><span class="line"></span><br><span class="line">spin_unlock_irqrestore(fifo-&gt;lock, flags);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在插入元素到队列时，需要加锁。缓冲区是一个内存块，在同一个内存块上操作，我们必须要保证元素进队列、元素出队列时，内存块的一致性。在锁内的临界区才是我们真正的进队列的操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> __kfifo_put(<span class="keyword">struct</span> kfifo *fifo, <span class="type">unsigned</span> <span class="type">char</span> *buffer, <span class="type">unsigned</span> <span class="type">int</span> len)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> l;</span><br><span class="line"></span><br><span class="line">len = min(len, fifo-&gt;size - fifo-&gt;in + fifo-&gt;out);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* first put the data starting from fifo-&gt;in to buffer end */</span></span><br><span class="line">l = min(len, fifo-&gt;size - (fifo-&gt;in &amp; (fifo-&gt;size - <span class="number">1</span>)));</span><br><span class="line"><span class="built_in">memcpy</span>(fifo-&gt;buffer + (fifo-&gt;in &amp; (fifo-&gt;size - <span class="number">1</span>)), buffer, l);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* then put the rest (if any) at the beginning of the buffer */</span></span><br><span class="line"><span class="built_in">memcpy</span>(fifo-&gt;buffer, buffer + l, len - l);</span><br><span class="line"></span><br><span class="line">fifo-&gt;in += len;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上所示，此操作是元素进队列的操作，该方法把 buffer 指针所指向的 len 字节数据拷贝到 fifo 所指的队列中。这里就牵涉到 fifo 队列的缓冲区是否放得下 buffer 的问题。</p><p><img src="/2023/11/12/%E9%A1%B9%E7%9B%AE/Linux%E7%A0%94%E7%A9%B6/%E5%86%85%E6%A0%B8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E9%98%9F%E5%88%97/%E8%BF%9B%E9%98%9F%E5%88%97.png"></p><p>如图，粉色部分已经写入元素了，其他部分尚未写入，是空闲的。注意，图中的 in、out 可能是 <code>N * fifo-&gt;size + in</code> 和 <code>M * fifo-&gt;size + out</code>。但总归 in 是要大于 out 的。</p><ul><li><p>首先，<code>fifo-&gt;size - fifo-&gt;in + fifo-&gt;out</code> 标识 fifo 缓冲区还剩下多少空间可以写，然后和 len 比较，取一个最小值，最为新的 len 长度。这个 len 就是最终要写入的数据大小。</p></li><li><p>我们可以看出来，fifo 缓冲区 <code>[out, in]</code> 这一段是有值的，不可写入。然后 <code>[0, out]、[in, fifo.size]</code> 这两个区间是可以写入的空间内存块。</p></li><li><p>于是乎，我们先写入 <code>[in, fifo.size]</code> 这个区间，如果这个区间可以写得下，那就直接写这个区间。所以有了这两句代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">l = min(len, fifo-&gt;size - (fifo-&gt;in &amp; (fifo-&gt;size - 1)));</span><br><span class="line">memcpy(fifo-&gt;buffer + (fifo-&gt;in &amp; (fifo-&gt;size - 1)), buffer, l);</span><br></pre></td></tr></table></figure><p>其中 <code>(fifo-&gt;in &amp; (fifo-&gt;size - 1))</code> 这句的含义来解释下。我们知道 <code>fifo-&gt;size</code> 的值为 2 的幂，那么其实这句代码的结果就是 <code>fifo-&gt;in</code> 除以 <code>fifo-&gt;size</code> 后的余数，这是因为用 2 的幂做位运算相当于对 2 的幂取模。</p><p>于是整体 <code>min(len, fifo-&gt;size - (fifo-&gt;in &amp; (fifo-&gt;size - 1)))</code> 就计算出可以安全添加到 <code>[in, fifo.size]</code> 这个区间的元素数量。</p><p>然后使用 memcpy 将元素拷贝到缓冲区，也即 <code>[in, fifo.size]</code> 这个区间。</p></li><li><p>如果 buffer 中元素没有拷贝完，则继续将 buffer 中剩余元素拷贝到 <code>[0, out]</code> 这个区间。</p></li><li><p>最后给 <code>fifo-&gt;in</code> 加上总共拷贝了多少元素。从这里我们可以看出 <code>fifo-&gt;in</code> 的值有可能是大于 <code>fifo-&gt;size</code>（缓冲区大小）的</p></li></ul><p>最后返回的也是本次进队列的元素个数。</p><h3 id="三、出队列"><a href="#三、出队列" class="headerlink" title="三、出队列"></a>三、出队列</h3><p>出队列则是利用了 out 出口偏移这个字段。也需要加锁来保证读写 fifo 缓冲区数据安全。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">kfifo_get</span><span class="params">(<span class="keyword">struct</span> kfifo *fifo,</span></span><br><span class="line"><span class="params">     <span class="type">unsigned</span> <span class="type">char</span> *buffer, <span class="type">unsigned</span> <span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">spin_lock_irqsave(fifo-&gt;lock, flags);</span><br><span class="line"></span><br><span class="line">ret = __kfifo_get(fifo, buffer, len);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * optimization: if the FIFO is empty, set the indices to 0</span></span><br><span class="line"><span class="comment"> * so we don&#x27;t wrap the next time</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (fifo-&gt;in == fifo-&gt;out)</span><br><span class="line">fifo-&gt;in = fifo-&gt;out = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">spin_unlock_irqrestore(fifo-&gt;lock, flags);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>同样的，在出队列时，需要加锁。这里有一点小优化，如果 fifo 为空，则说明 <code>fifo-&gt;in</code> 和 <code>fifo-&gt;out</code> 相等，此时我们让入口偏移和出口偏移都设置为 0。再来看真正的出队列的操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> __kfifo_get(<span class="keyword">struct</span> kfifo *fifo, <span class="type">unsigned</span> <span class="type">char</span> *buffer, <span class="type">unsigned</span> <span class="type">int</span> len)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> l;</span><br><span class="line"></span><br><span class="line">len = min(len, fifo-&gt;in - fifo-&gt;out);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* first get the data from fifo-&gt;out until the end of the buffer */</span></span><br><span class="line">l = min(len, fifo-&gt;size - (fifo-&gt;out &amp; (fifo-&gt;size - <span class="number">1</span>)));</span><br><span class="line"><span class="built_in">memcpy</span>(buffer, fifo-&gt;buffer + (fifo-&gt;out &amp; (fifo-&gt;size - <span class="number">1</span>)), l);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* then get the rest (if any) from the beginning of the buffer */</span></span><br><span class="line"><span class="built_in">memcpy</span>(buffer + l, fifo-&gt;buffer, len - l);</span><br><span class="line"></span><br><span class="line">fifo-&gt;out += len;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>首先通过 <code>fifo-&gt;in - fifo-&gt;out</code> 来计算出缓冲区已经写入了多少元素，和用户传入的 len 取最小值。</li><li>因为缓冲区是一个循环写入的缓冲区，有可能出现的情况是如下：</li></ul><p><img src="/2023/11/12/%E9%A1%B9%E7%9B%AE/Linux%E7%A0%94%E7%A9%B6/%E5%86%85%E6%A0%B8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E9%98%9F%E5%88%97/%E5%87%BA%E9%98%9F%E5%88%97.png"></p><ul><li>可不要误解哈， out 的值是一定小于 in 的值的。需要注意：图中的 in、out 是 <code>N * fifo-&gt;size + in</code> 和 <code>M * fifo-&gt;size + out</code>。总归 in 是要大于 out 的。</li><li>但这种情况，我们只能先取 <code>[out, fifo-&gt;size]</code> 这个区间的元素，再来取 <code>[0, in]</code> 这个区间的元素。思路和进队列的思路完全一致。在此不多说明</li><li>最后给 <code>fifo-&gt;out</code> 加上取出的元素数量</li></ul><p>返回真正取出的元素数量。</p><h3 id="四、重置队列"><a href="#四、重置队列" class="headerlink" title="四、重置队列"></a>四、重置队列</h3><p>重置队列的过程比较简单，就是将 <code>fifo-&gt;in</code> 和 <code>fifo-&gt;out</code> 置为 0。当然也是在加锁的前提下的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> __kfifo_reset(<span class="keyword">struct</span> kfifo *fifo)</span><br><span class="line">&#123;</span><br><span class="line">fifo-&gt;in = fifo-&gt;out = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">kfifo_reset</span><span class="params">(<span class="keyword">struct</span> kfifo *fifo)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line"></span><br><span class="line">spin_lock_irqsave(fifo-&gt;lock, flags);</span><br><span class="line"></span><br><span class="line">__kfifo_reset(fifo);</span><br><span class="line"></span><br><span class="line">spin_unlock_irqrestore(fifo-&gt;lock, flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="五、队列长度"><a href="#五、队列长度" class="headerlink" title="五、队列长度"></a>五、队列长度</h3><p>求取队列长度也比较简单，只需要 <code>fifo-&gt;in - fifo-&gt;out</code> 即可得到当前队列中元素的数量。当然也需要加锁，因为需要保证在求队列长度时，别的方法不能修改缓冲区大小。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">unsigned</span> <span class="type">int</span> __kfifo_len(<span class="keyword">struct</span> kfifo *fifo)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> fifo-&gt;in - fifo-&gt;out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">kfifo_len</span><span class="params">(<span class="keyword">struct</span> kfifo *fifo)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">spin_lock_irqsave(fifo-&gt;lock, flags);</span><br><span class="line"></span><br><span class="line">ret = __kfifo_len(fifo);</span><br><span class="line"></span><br><span class="line">spin_unlock_irqrestore(fifo-&gt;lock, flags);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="六、说明"><a href="#六、说明" class="headerlink" title="六、说明"></a>六、说明</h3><p>队列整体比较简单，这一版的队列实现中也没有支持扩容、缩容。只能在创建队列时，设定好缓冲区大小。其实，特别像我们所说的生产者消费者模型，缓冲区作为中介，生产者和消费者都来更新缓冲区的入口偏移、出口偏移等。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;队列是一种定义了 FIFO 先进先出的结构。Linux 内核的队列实现在 &lt;code&gt;kfifo.c&lt;/code&gt; 中。本文以 &lt;code&gt;Linux 2.6.12&lt;/code&gt; 版本来进行讨论。&lt;/p&gt;
&lt;p&gt;我们还是老样子，从底层实现看起，然后再来总结规律、适用场景。&lt;</summary>
      
    
    
    
    <category term="项目" scheme="https://noahyzhang.github.io/categories/%E9%A1%B9%E7%9B%AE/"/>
    
    <category term="Linux研究" scheme="https://noahyzhang.github.io/categories/%E9%A1%B9%E7%9B%AE/Linux%E7%A0%94%E7%A9%B6/"/>
    
    
  </entry>
  
  <entry>
    <title>内核数据结构之链表</title>
    <link href="https://noahyzhang.github.io/2023/11/05/%E9%A1%B9%E7%9B%AE/Linux%E7%A0%94%E7%A9%B6/%E5%86%85%E6%A0%B8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E9%93%BE%E8%A1%A8/"/>
    <id>https://noahyzhang.github.io/2023/11/05/%E9%A1%B9%E7%9B%AE/Linux%E7%A0%94%E7%A9%B6/%E5%86%85%E6%A0%B8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E9%93%BE%E8%A1%A8/</id>
    <published>2023-11-05T01:55:54.237Z</published>
    <updated>2023-11-12T10:34:25.783Z</updated>
    
    <content type="html"><![CDATA[<p>链表是一种存放和操作可变数量元素（常称为节点）的数据结构。他们在内存中无须占有连续内存块，内存块之间通过指针连接。本文探讨一下 Linux 中链表的实现。</p><h3 id="一、链表的定义"><a href="#一、链表的定义" class="headerlink" title="一、链表的定义"></a>一、链表的定义</h3><p>Linux 内核中，<strong>不是将数据结构塞入链表，而是将链表节点塞入数据结构</strong>。</p><p>比如我们之前定义链表，一般是有了结构体，然后在此结构体中增加 “前向指针” 或者“ 后向指针”，以达到链表将节点串联起来的目的。而 Linux 内核中，是将链表节点塞入数据结构体中，以达到同样的效果。</p><p>链表代码在头文件：<code>&lt;linux/include/linux/list.h&gt;</code> 中声明，数据结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">next</span>, *<span class="title">prev</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>将此链表节点塞入数据结构中，即可得到一个链表。那如何去操作这个链表呢？内核提供了一些方法。这些方法有一个统一的特点：他们只接受 list_head 结构作为参数。使用宏 <code>container_of()</code> 可以很方便的从链表指针找到父结构中包含的任何变量。</p><p>因为在 C 语言中，一个给定结构中的变量偏移在编译时，地址就被 ABI 确定了。如下这样的宏定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> container_of(ptr, type, member) (&#123;                \</span></span><br><span class="line"><span class="meta">const typeof( ((type*)0)-&gt;member ) * __mptr = (ptr);  \</span></span><br><span class="line"><span class="meta">(type*)( (char*)__mptr - offsetof(type, member) );    \</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br></pre></td></tr></table></figure><p>下面我们实际定义一个结构体体验一下。也就是将链表塞入我们定义的数据结构中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dummyStruct</span> &#123;</span></span><br><span class="line"><span class="type">int</span> dummy_node;         <span class="comment">// 结构体节点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span>  <span class="comment">// 链表节点</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>链表需要在使用的时候初始化，有两种方式，一种是运行时初始化，另外一种是编译器静态创建。如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dummyStruct</span>* <span class="title">node</span> =</span> kmalloc(<span class="keyword">sizeof</span>(*node), GFP_KERNEL);</span><br><span class="line">node-&gt;dummy_node = <span class="number">10</span>;</span><br><span class="line">INIT_LIST_HEAD(&amp;node-&gt;<span class="built_in">list</span>);   <span class="comment">// 初始化链表节点（运行时初始化）</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dummyStruct</span> <span class="title">static_node</span> =</span> &#123;</span><br><span class="line">.dummy_node = <span class="number">10</span>,</span><br><span class="line">.<span class="built_in">list</span> = LIST_HEAD_INIT(static_node.<span class="built_in">list</span>),   <span class="comment">// 静态初始化链表节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那我们继续看看初始化 <code>LIST_HEAD_INIT </code> 宏定义都干了什么事情？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LIST_HEAD_INIT(name) &#123; &amp;(name), &amp;(name) &#125;</span></span><br></pre></td></tr></table></figure><p>到这里，我们明白了，初始化链表节点的时候，会将链表节点中的前向指针、后向指针都指向自己。也就是说链表是一个循环链表。</p><h3 id="二、操作链表"><a href="#二、操作链表" class="headerlink" title="二、操作链表"></a>二、操作链表</h3><p>一般数据结构都是要有增删改查操作的，链表也不例外。下面我们来探讨这几种操作</p><h4 id="1-向链表增加一个节点"><a href="#1-向链表增加一个节点" class="headerlink" title="1. 向链表增加一个节点"></a>1. 向链表增加一个节点</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">list_add</span><span class="params">(<span class="keyword">struct</span> list_head *new, <span class="keyword">struct</span> list_head *head)</span></span><br><span class="line">&#123;</span><br><span class="line">__list_add(new, head, head-&gt;next);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> __list_add(<span class="keyword">struct</span> list_head *new,</span><br><span class="line">      <span class="keyword">struct</span> list_head *prev,</span><br><span class="line">      <span class="keyword">struct</span> list_head *next)</span><br><span class="line">&#123;</span><br><span class="line">next-&gt;prev = new;</span><br><span class="line">new-&gt;next = next;</span><br><span class="line">new-&gt;prev = prev;</span><br><span class="line">prev-&gt;next = new;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>给出一个需要插入的节点 new，以及要插入的位置 head。此实现是在 head 的后面插入节点 new。然后分别将对应的前向指针、后向指针进行补齐填充即可。</p><p>那我们注意了，我们考虑边界情况，假如 head 是链表的最后一个节点。这样插入岂不是对空指针解引用？这不是 bug 嘛？NO，刚才我们提到，使用宏定义 <code>LIST_HEAD_INIT</code> 初始化链表节点时，会让链表节点的前向指针、后向指针指向自己。我们说链表是一个循环链表。  那么是如何形成环形链表呢？我们来列举一下。</p><p>只有一个节点时，节点的前向指针、后向指针都指向自己。那么此时插入一个新节点时，通过以上的逻辑，可以得到如下的环形链表：</p><p><img src="/2023/11/05/%E9%A1%B9%E7%9B%AE/Linux%E7%A0%94%E7%A9%B6/%E5%86%85%E6%A0%B8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E9%93%BE%E8%A1%A8/%E5%86%85%E6%A0%B8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8.png"></p><p>还有一个方法是添加一个新节点到链表末尾。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">list_add_tail</span><span class="params">(<span class="keyword">struct</span> list_head *new, <span class="keyword">struct</span> list_head *head)</span></span><br><span class="line">&#123;</span><br><span class="line">__list_add(new, head-&gt;prev, head);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上的实现就是 new 节点插入到 head 节点的前面。如果我们认为 head 节点是链表的头节点的话，而且由于链表是环形链表。所以添加到 head 节点的前面，就相当于添加到链表的尾部。</p><p>因此，我们可以扩展一下，当我们总把最后的一个节点当作 head 的话，那么 <code>list_add</code> 此方法是不是就可以实现一个栈。</p><p>如果我们总把第一个节点当作 head 的话，那么每次都往第一个节点前面插入节点，那么 <code>list_add_tail</code> 方法就可以实现一个队列。</p><p>所以环形链表的适用处特别多。</p><h4 id="2-从链表中删除一个节点"><a href="#2-从链表中删除一个节点" class="headerlink" title="2. 从链表中删除一个节点"></a>2. 从链表中删除一个节点</h4><p>我们先来看源码实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LIST_POISON1  ((void *) 0x00100100)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LIST_POISON2  ((void *) 0x00200200)</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> __list_del(<span class="keyword">struct</span> list_head * prev, <span class="keyword">struct</span> list_head * next)</span><br><span class="line">&#123;</span><br><span class="line">next-&gt;prev = prev;</span><br><span class="line">prev-&gt;next = next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">list_del</span><span class="params">(<span class="keyword">struct</span> list_head *entry)</span></span><br><span class="line">&#123;</span><br><span class="line">__list_del(entry-&gt;prev, entry-&gt;next);</span><br><span class="line">entry-&gt;next = LIST_POISON1;</span><br><span class="line">entry-&gt;prev = LIST_POISON2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从链表中删除一个节点，需要传入待删除的节点指针 entry。而 Linux 内核内部仅仅是将这个节点从链表中取出，并不会释放这个节点所占用的内存空间。所以在使用的时候，别忘了从链表中删除完节点后，还要释放 entry 节点所占有的空间。</p><p>还有一点，从链表中删除节点后，会将此节点的 next、prev 指针置为一个指定的非法值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define LIST_POISON1  ((void *) 0x00100100)</span><br><span class="line">#define LIST_POISON2  ((void *) 0x00200200)</span><br></pre></td></tr></table></figure><p>使用这些指定的非 NULL 指针，可以快速发现问题。比如如果有人使用这个已经被删除的节点，那么就出现 page fault，甚至 core。当然使用 NULL 指针也可以做到这一点，不过我觉得 NULL 指针用的太过广泛，不利于排查问题。</p><h4 id="3-移动链表节点"><a href="#3-移动链表节点" class="headerlink" title="3. 移动链表节点"></a>3. 移动链表节点</h4><p>此方法的功能是：从一个链表取出某个节点，然后放在另一个链表中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">list_move</span><span class="params">(<span class="keyword">struct</span> list_head *<span class="built_in">list</span>, <span class="keyword">struct</span> list_head *head)</span></span><br><span class="line">&#123;</span><br><span class="line">        __list_del(<span class="built_in">list</span>-&gt;prev, <span class="built_in">list</span>-&gt;next);</span><br><span class="line">        list_add(<span class="built_in">list</span>, head);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中第一个参数 list 就是待转移的节点，先从原链表中删除，然后将此节点加入到 head 所在的链表中，并且加入到 head 节点之后。</p><p>我们再来看另外一个方法。此方法的功能是：从一个链表取出某个节点，然后放入另一个链表中，只不过是放入另一个链表的末尾（这里假定的是 head 为链表的头节点）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">list_move_tail</span><span class="params">(<span class="keyword">struct</span> list_head *<span class="built_in">list</span>,</span></span><br><span class="line"><span class="params">  <span class="keyword">struct</span> list_head *head)</span></span><br><span class="line">&#123;</span><br><span class="line">        __list_del(<span class="built_in">list</span>-&gt;prev, <span class="built_in">list</span>-&gt;next);</span><br><span class="line">        list_add_tail(<span class="built_in">list</span>, head);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-合并链表"><a href="#4-合并链表" class="headerlink" title="4. 合并链表"></a>4. 合并链表</h4><p>将两个未连接的链表合并在一起。如下实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> __list_splice(<span class="keyword">struct</span> list_head *<span class="built_in">list</span>, <span class="keyword">struct</span> list_head *head)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">first</span> =</span> <span class="built_in">list</span>-&gt;next;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">last</span> =</span> <span class="built_in">list</span>-&gt;prev;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">at</span> =</span> head-&gt;next;</span><br><span class="line"></span><br><span class="line">first-&gt;prev = head;</span><br><span class="line">head-&gt;next = first;</span><br><span class="line"></span><br><span class="line">last-&gt;next = at;</span><br><span class="line">at-&gt;prev = last;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">list_splice</span><span class="params">(<span class="keyword">struct</span> list_head *<span class="built_in">list</span>, <span class="keyword">struct</span> list_head *head)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!list_empty(<span class="built_in">list</span>))</span><br><span class="line">__list_splice(<span class="built_in">list</span>, head);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上实现，是将 list 这个链表插入到 head 链表中。不过需要注意的是，不包括 list 本身的这个节点。意思就是说：假设 list 链表是 <code>1,2,3,4,5</code> 这 5 个元素，head 链表是 <code>6,7,8,9,10</code>。合并完之后，head 链表会变成 <code>6,2,3,4,5,7,8,9,10</code>。</p><p>我们画个图说明一下：</p><p><img src="/2023/11/05/%E9%A1%B9%E7%9B%AE/Linux%E7%A0%94%E7%A9%B6/%E5%86%85%E6%A0%B8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E9%93%BE%E8%A1%A8/%E5%90%88%E5%B9%B6%E9%93%BE%E8%A1%A81.png"></p><p>经过合并之后，会变成如下的样子：</p><p><img src="/2023/11/05/%E9%A1%B9%E7%9B%AE/Linux%E7%A0%94%E7%A9%B6/%E5%86%85%E6%A0%B8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E9%93%BE%E8%A1%A8/%E5%90%88%E5%B9%B6%E9%93%BE%E8%A1%A82.png"></p><p>所以一定要注意，使用此方式，合并的时候，被合并的链表并不包含当前节点。并且会插入 head 链表中 head 节点的后边。</p><p>这么说的话，合并完之后，list 节点还指向原来的链表。是一个较为尴尬的存在，因为 list 节点所指向的链表已经合并到 head 链表中，于是内核还提供了另外一个方法，用于合并完之后将 list 节点进行初始化。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">list_splice_init</span><span class="params">(<span class="keyword">struct</span> list_head *<span class="built_in">list</span>,</span></span><br><span class="line"><span class="params">    <span class="keyword">struct</span> list_head *head)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!list_empty(<span class="built_in">list</span>)) &#123;</span><br><span class="line">__list_splice(<span class="built_in">list</span>, head);</span><br><span class="line">INIT_LIST_HEAD(<span class="built_in">list</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上的实现中，这样合并后，并且将 list 节点初始化后，就不存在通过 list 节点修改 head 链表的情况了。list 节点此时成为了一个单节点的循环链表。</p><p>不过，个人感觉这种实现不太好，既然是合并链表，那就应该将链表中所有元素都给合并了，留一个元素做什么？这里需要考究一下原因。如果有合并所有元素的场景，只能设置一个傀儡节点做链表的头节点了，合并完再释放掉傀儡节点即可。</p><h4 id="5-遍历链表"><a href="#5-遍历链表" class="headerlink" title="5. 遍历链表"></a>5. 遍历链表</h4><p>遍历链表提供了访问数据的功能。时间复杂度为 <code>O(n)</code>，n 是链表元素数量。</p><p>最简单的方法是使用 <code>list_for_each()</code> 宏，需要两个参数，第一个参数用来指向当前项，第二个参数是待遍历的链表的头节点。每次遍历中，第一个参数在链表中不断移动指向下一个元素，直到链表中所有元素都被访问为止。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> list_for_each(pos, head) \</span></span><br><span class="line"><span class="meta">for (pos = (head)-&gt;next; prefetch(pos-&gt;next), pos != (head); \</span></span><br><span class="line"><span class="meta">        pos = pos-&gt;next)</span></span><br></pre></td></tr></table></figure><p>我们也看到了，这个宏他不会遍历当前节点。他上来就让 pos 指针指向了 <code>head-&gt;next</code>，而且结束条件是 <code>pos != head</code>，也就是根本不会遍历当前节点。</p><p>清楚这一点之后，我们还需要注意，这个宏只是在遍历链表，但是我们需要的是链表所在的结构体，那个结构体中的内容才是我们想要的数据。我们如何通过链表节点获取到结构体中的数据呢？是使用 <code>list_entry</code> 宏。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> container_of(ptr, type, member) (&#123;\</span></span><br><span class="line"><span class="meta">        const typeof( ((type *)0)-&gt;member ) *__mptr = (ptr);\</span></span><br><span class="line"><span class="meta">        (type *)( (char *)__mptr - offsetof(type,member) );&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> list_entry(ptr, type, member) \</span></span><br><span class="line"><span class="meta">container_of(ptr, type, member)</span></span><br></pre></td></tr></table></figure><p>在 C 语言中，一个给定结构中的变量偏移在编译时，地址就被 ABI 确定了。也就是说，一个结构体中的各个字段在编译时，字段位置是固定的，只要给定这个结构体内存地址，以及结构体定义的结构，那么可以确定所有字段的在结构体的位置，即内存地址。通过 offsetof 可以确定出来结构体成员在结构体中的偏移。</p><p>因此，我们的遍历方法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dummyStruct</span> &#123;</span></span><br><span class="line"><span class="type">int</span> dummy_node;         <span class="comment">// 结构体节点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span>  <span class="comment">// 链表节点</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>* <span class="title">p</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dummyStruct</span>* <span class="title">f</span>;</span></span><br><span class="line">list_for_each(p, &amp;f_list) &#123;  <span class="comment">// f_list 为链表头节点</span></span><br><span class="line">f = list_entry(p, <span class="keyword">struct</span> dummyStruct, <span class="built_in">list</span>);</span><br><span class="line"><span class="comment">// 这里可以操作 f 所指向的结构体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面再来介绍一种更为方便的方法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> list_for_each_entry(pos, head, member)\</span></span><br><span class="line"><span class="meta">for (pos = list_entry((head)-&gt;next, typeof(*pos), member);\</span></span><br><span class="line"><span class="meta">     prefetch(pos-&gt;member.next), &amp;pos-&gt;member != (head); \</span></span><br><span class="line"><span class="meta">     pos = list_entry(pos-&gt;member.next, typeof(*pos), member))</span></span><br></pre></td></tr></table></figure><p>使用 <code>list_for_each_entry</code> 宏更加方便一点，pos 参数是一个指向链表节点的指针，也是 <code>list_entry</code> 宏的返回值。head 是一个指向链表头节点的指针，即遍历开始位置。member 则是结构体中 list_head 为类型的变量名，用于找到链表下一个节点的位置。</p><p>其中 prefetch 暂时不用管，他用于从内存预取数据到寄存器，为了加快执行速度。和链表本身的实现没有什么关系。我们来看看他的用法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dummyStruct</span>* <span class="title">f</span>;</span></span><br><span class="line">list_for_each_entry(f, &amp;f_list, <span class="built_in">list</span>) &#123;  <span class="comment">// f_list 为链表头节点</span></span><br><span class="line"><span class="comment">// 直接使用 f 所指向的结构体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>反向遍历链表</strong></p><p>宏 <code>list_for_each_entry_reverse</code> 可以用来反向遍历链表。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#define list_for_each_entry_reverse(pos, head, member)\</span><br><span class="line">for (pos = list_entry((head)-&gt;prev, typeof(*pos), member);\</span><br><span class="line">     prefetch(pos-&gt;member.prev), &amp;pos-&gt;member != (head); \</span><br><span class="line">     pos = list_entry(pos-&gt;member.prev, typeof(*pos), member))</span><br></pre></td></tr></table></figure><p>因为链表是环形双向链表，有前向指针、后向指针。所以反向遍历的时候，只需要使用 prev 指针即可。</p><p>反向遍历在很多场景中都有用途，主要有两大场景。第一如果我们知道要寻找的节点可能在我们搜索的起始点的前面，那么反向查找就很快速，这是性能的提升。第二如果我们使用链表实现堆栈，那么我们需要向前遍历才能达到先进先出（<code>LIFO</code>）。</p><p><strong>边遍历边删除</strong></p><p>以上的两种方法在遍历的时候不能删除，因为他还需要遍历到的当前节点找到后一个节点、或者前一个节点。于是 Linux 内核提供了一种安全的遍历方式，即通过在潜在的删除操作之前存储 next（或者 prev）指针到一个临时变量中，以便可以执行删除操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> list_for_each_entry_safe(pos, n, head, member)\</span></span><br><span class="line"><span class="meta">for (pos = list_entry((head)-&gt;next, typeof(*pos), member),\</span></span><br><span class="line"><span class="meta">n = list_entry(pos-&gt;member.next, typeof(*pos), member);\</span></span><br><span class="line"><span class="meta">     &amp;pos-&gt;member != (head); \</span></span><br><span class="line"><span class="meta">     pos = n, n = list_entry(n-&gt;member.next, typeof(*n), member))</span></span><br></pre></td></tr></table></figure><p>如上实现，多了一个 n 参数，其实就是 next 指针，需要我们提供 next 指针，而 next 指针和 pos 指针是同样的类型。而 <code>list_for_each_entry_safe</code> 宏将 next 指针存储起来，这样我们就可以安全的删除当前项。</p><p>这里在强调一遍，这里的接口都不是线程安全的。遍历的同时删除节点，保证的是“避免使用前释放的错误”，而不能保证线程并发的安全。</p><h3 id="三、举例"><a href="#三、举例" class="headerlink" title="三、举例"></a>三、举例</h3><p>我们熟悉了接口的实现后，再来整体看看如何使用链表。下面的例子我们将创建一个链表，并且对此链表进行增删改查。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stddef.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __KERNEL__</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;list.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BizStu</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">for_each_list</span><span class="params">(<span class="keyword">struct</span> BizStu* obj)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>* <span class="title">pos</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, list_entry(&amp;obj-&gt;<span class="built_in">list</span>, <span class="keyword">struct</span> BizStu, <span class="built_in">list</span>)-&gt;id);</span><br><span class="line">    list_for_each(pos, &amp;obj-&gt;<span class="built_in">list</span>) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">BizStu</span>* <span class="title">node</span> =</span> list_entry(pos, <span class="keyword">struct</span> BizStu, <span class="built_in">list</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, node-&gt;id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 创建结构体，并初始化链表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BizStu</span>* <span class="title">head1</span> =</span> <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> BizStu));</span><br><span class="line">    head1-&gt;id = <span class="number">0</span>;</span><br><span class="line">    INIT_LIST_HEAD(&amp;head1-&gt;<span class="built_in">list</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加结构体节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">BizStu</span>* <span class="title">tmp_node</span> =</span> <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> BizStu));</span><br><span class="line">        tmp_node-&gt;id = i;</span><br><span class="line">        INIT_LIST_HEAD(&amp;tmp_node-&gt;<span class="built_in">list</span>);</span><br><span class="line">        list_add(&amp;tmp_node-&gt;<span class="built_in">list</span>, &amp;head1-&gt;<span class="built_in">list</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 打印链表</span></span><br><span class="line">    for_each_list(head1);  <span class="comment">// 0 9 8 7 6 5 4 3 2 1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从链表中删除节点</span></span><br><span class="line">    list_del(head1-&gt;<span class="built_in">list</span>.next); <span class="comment">// 删除 9 这个节点</span></span><br><span class="line">    <span class="comment">// 打印链表</span></span><br><span class="line">    for_each_list(head1);  <span class="comment">// 0 8 7 6 5 4 3 2 1</span></span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BizStu</span>* <span class="title">head2</span> =</span> <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> BizStu));</span><br><span class="line">    head2-&gt;id = <span class="number">100</span>;</span><br><span class="line">    INIT_LIST_HEAD(&amp;head2-&gt;<span class="built_in">list</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">200</span>; i &lt; <span class="number">500</span>; i += <span class="number">100</span>) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">BizStu</span>* <span class="title">tmp_node</span> =</span> <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> BizStu));</span><br><span class="line">        tmp_node-&gt;id = i;</span><br><span class="line">        INIT_LIST_HEAD(&amp;tmp_node-&gt;<span class="built_in">list</span>);</span><br><span class="line">        list_add(&amp;tmp_node-&gt;<span class="built_in">list</span>, &amp;head2-&gt;<span class="built_in">list</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    for_each_list(head2);  <span class="comment">// 100 400 300 200</span></span><br><span class="line">    <span class="comment">// 移动链表节点</span></span><br><span class="line">    list_move(head2-&gt;<span class="built_in">list</span>.next, &amp;head1-&gt;<span class="built_in">list</span>);  <span class="comment">// 将 400 从 head2 链表中移动到 head1 链表中</span></span><br><span class="line">    for_each_list(head1);  <span class="comment">// 0 400 8 7 6 5 4 3 2 1</span></span><br><span class="line">    for_each_list(head2);  <span class="comment">// 100 300 200</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并链表</span></span><br><span class="line">    list_splice_init(&amp;head2-&gt;<span class="built_in">list</span>, &amp;head1-&gt;<span class="built_in">list</span>); <span class="comment">// 将 head2 链表合并到 head1 中来</span></span><br><span class="line">    for_each_list(head1);  <span class="comment">// 0 300 200 400 8 7 6 5 4 3 2 1</span></span><br><span class="line">    for_each_list(head2);  <span class="comment">// 100</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 边遍历边删除</span></span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BizStu</span> *<span class="title">pos</span> =</span> <span class="literal">NULL</span>, *next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, head1-&gt;id);</span><br><span class="line">    list_for_each_entry_safe(pos, next, &amp;head1-&gt;<span class="built_in">list</span>, <span class="built_in">list</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (count &gt; <span class="number">2</span>) &#123;</span><br><span class="line">            list_del(&amp;pos-&gt;<span class="built_in">list</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, pos-&gt;id);</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);  <span class="comment">// 0 300 200 400 8 7 6 5 4 3 2 1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 上面已经删除完了，再来遍历一次看效果</span></span><br><span class="line">    for_each_list(head1);  <span class="comment">// 0 300 200 400</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中头文件 <code>list.h</code> 需要做一些修改，已经打包上传到 git 了。</p><p>git 地址：<code>https://github.com/noahyzhang/kernel_test</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;链表是一种存放和操作可变数量元素（常称为节点）的数据结构。他们在内存中无须占有连续内存块，内存块之间通过指针连接。本文探讨一下 Linux 中链表的实现。&lt;/p&gt;
&lt;h3 id=&quot;一、链表的定义&quot;&gt;&lt;a href=&quot;#一、链表的定义&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="项目" scheme="https://noahyzhang.github.io/categories/%E9%A1%B9%E7%9B%AE/"/>
    
    <category term="Linux研究" scheme="https://noahyzhang.github.io/categories/%E9%A1%B9%E7%9B%AE/Linux%E7%A0%94%E7%A9%B6/"/>
    
    
  </entry>
  
  <entry>
    <title>SpringBoot 项目使用 JdbcTemplate</title>
    <link href="https://noahyzhang.github.io/2023/10/28/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/java%E8%AF%AD%E8%A8%80/%E5%9F%BA%E7%A1%80/SpringBoot%E4%BD%BF%E7%94%A8JdbcTemplate/"/>
    <id>https://noahyzhang.github.io/2023/10/28/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/java%E8%AF%AD%E8%A8%80/%E5%9F%BA%E7%A1%80/SpringBoot%E4%BD%BF%E7%94%A8JdbcTemplate/</id>
    <published>2023-10-28T10:23:08.895Z</published>
    <updated>2023-10-28T10:30:18.507Z</updated>
    
    <content type="html"><![CDATA[<p>我们都知道使用原始的JDBC在操作数据库是比较麻烦的，所以Spring为了提高开发的效率，顺带着就把JDBC封装、改造了一番，而JdbcTemplate就是Spring对原始JDBC封装之后提供的一个操作数据库的工具类。</p><p>我们可以借助JdbcTemplate来完成所有数据库操作，比如：增删改查等。</p><p>JdbcTemplate主要提供以下三种类型的方法：</p><ul><li>executeXxx() : 执行任何SQL语句，对数据库、表进行新建、修改、删除操作</li><li>updateXxx() : 执行新增、修改、删除等语句</li><li>queryXxx() : 执行查询相关的语句</li></ul><p>JdbcTemplate算是最简单的数据持久层方案，实际开发过程中，我们会使用mybatis、hibernate、jpa等持久化框架。</p><p>与JdbcTemplate类似的还有NamedParameterJdbcTemplate。</p><p>增加 pom 依赖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- JDBC --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">        </span><br><span class="line"> &lt;dependency&gt;</span><br><span class="line">     &lt;groupId&gt;com.mchange&lt;/groupId&gt;</span><br><span class="line">     &lt;artifactId&gt;c3p0&lt;/artifactId&gt;</span><br><span class="line">     &lt;version&gt;0.9.5.5&lt;/version&gt;</span><br><span class="line">     &lt;scope&gt;compile&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- MySQL 驱动包--&gt;</span><br><span class="line">&lt;!--MySQL Server 版本为 8.x时，mysql-connector-java使用5.1.35时会报错--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;8.0.11&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>application.properties</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 定义c3p0的配置，没有提示可以使用，数据库连接地址</span><br><span class="line">c3p0.jdbcUrl=jdbc:mysql://192.168.61.130:3306/spring_db?serverTimezone=Asia/Shanghai&amp;useUnicode=true&amp;charcterEncoding=UTF-8&amp;useSSL=false</span><br><span class="line">  # 数据库用户名</span><br><span class="line">c3p0.user=root</span><br><span class="line">  # 数据库密码</span><br><span class="line">c3p0.password=1234</span><br><span class="line">  # 数据库驱动程序</span><br><span class="line">#c3p0.driverClass=com.mysql.jdbc.Driver</span><br><span class="line">c3p0.driverClass=com.mysql.cj.jdbc.Driver</span><br><span class="line">  # 最小连接数</span><br><span class="line">c3p0.minPoolSize=2</span><br><span class="line">  # 最大连接数</span><br><span class="line">c3p0.maxPoolSize=10</span><br><span class="line">  # 最大等待时间</span><br><span class="line">c3p0.maxIdleTime=3000</span><br><span class="line">  # 初始化连接数</span><br><span class="line">c3p0.initialPoolSize=3</span><br></pre></td></tr></table></figure><p>配置数据源。只要配置了数据源就会自动注入JdbcTemplate Bean。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class DataSourceConfig &#123;</span><br><span class="line">    @Bean(name = &quot;dataSource&quot;)</span><br><span class="line">    //配置属性,prefix : 前缀 spring.datasource固定</span><br><span class="line">    @ConfigurationProperties(prefix = &quot;c3p0&quot;)</span><br><span class="line">    public DataSource createDataSource() &#123;</span><br><span class="line">        return DataSourceBuilder.create()</span><br><span class="line">                .type(ComboPooledDataSource.class) // 设置数据源类型</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <strong>NamedParameterJdbcTemplate</strong> </p><p>在经典的 JDBC 用法中, SQL 参数是用占位符 ? 表示,并且受到位置的限制。定位参数的问题在于, 一旦参数的顺序发生变化, 就必须改变参数绑定。</p><p>在 Spring JDBC 框架中, 绑定 SQL 参数的另一种选择是使用具名参数(named parameter)。</p><p>具名参数：SQL 按名称(以冒号开头)而不是按位置进行指定. 具名参数更易于维护, 也提升了可读性。具名参数由框架类在运行时用占位符取代。</p><p>具名参数只在 NamedParameterJdbcTemplate 中得到支持。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br><span class="line">public class UserController &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private NamedParameterJdbcTemplate namedParameterJdbcTemplate;</span><br><span class="line">    </span><br><span class="line">    @RequestMapping(value = &quot;/insertUser&quot;, method = RequestMethod.POST)</span><br><span class="line">    @ResponseBody</span><br><span class="line">    public void insertUser(@RequestBody UserParam param) &#123;</span><br><span class="line">        String sql = &quot;insert into user(id, email, username) values(:id, :email, :username)&quot;;</span><br><span class="line"></span><br><span class="line">        MapSqlParameterSource source = new MapSqlParameterSource();</span><br><span class="line">        source.addValue(&quot;id&quot;, param.getId());</span><br><span class="line">        source.addValue(&quot;email&quot;, param.getEmail());</span><br><span class="line">        source.addValue(&quot;username&quot;, param.getUsername());</span><br><span class="line">        namedParameterJdbcTemplate.update(sql, source);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我们都知道使用原始的JDBC在操作数据库是比较麻烦的，所以Spring为了提高开发的效率，顺带着就把JDBC封装、改造了一番，而JdbcTemplate就是Spring对原始JDBC封装之后提供的一个操作数据库的工具类。&lt;/p&gt;
&lt;p&gt;我们可以借助JdbcTemplate来</summary>
      
    
    
    
    <category term="编程语言" scheme="https://noahyzhang.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    <category term="java语言" scheme="https://noahyzhang.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/java%E8%AF%AD%E8%A8%80/"/>
    
    <category term="基础" scheme="https://noahyzhang.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/java%E8%AF%AD%E8%A8%80/%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://noahyzhang.github.io/2023/10/21/%E9%A1%B9%E7%9B%AE/%E9%93%BE%E6%8E%A5%E4%B8%8E%E8%A3%85%E8%BD%BD/README/"/>
    <id>https://noahyzhang.github.io/2023/10/21/%E9%A1%B9%E7%9B%AE/%E9%93%BE%E6%8E%A5%E4%B8%8E%E8%A3%85%E8%BD%BD/README/</id>
    <published>2023-10-21T14:22:16.752Z</published>
    <updated>2023-10-21T14:22:16.752Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="/%E9%A1%B9%E7%9B%AE/">返回上一级 [项目]</a></li><li><a href="/%E9%A1%B9%E7%9B%AE/%E9%93%BE%E6%8E%A5%E4%B8%8E%E8%A3%85%E8%BD%BD/">链接与装载</a><ul><li><a href="/%E9%A1%B9%E7%9B%AE/%E9%93%BE%E6%8E%A5%E4%B8%8E%E8%A3%85%E8%BD%BD/1.%E9%A2%84%E5%A4%84%E7%90%86%E3%80%81%E7%BC%96%E8%AF%91%E3%80%81%E6%B1%87%E7%BC%96%E3%80%81%E9%93%BE%E6%8E%A5%E8%BF%87%E7%A8%8B.md">1.预处理、编译、汇编、链接过程</a></li><li><a href="/%E9%A1%B9%E7%9B%AE/%E9%93%BE%E6%8E%A5%E4%B8%8E%E8%A3%85%E8%BD%BD/2.%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%9A%84%E8%A3%85%E8%BD%BD%E4%B8%8E%E6%89%A7%E8%A1%8C.md">2.二进制的装载与执行</a></li><li><a href="/%E9%A1%B9%E7%9B%AE/%E9%93%BE%E6%8E%A5%E4%B8%8E%E8%A3%85%E8%BD%BD/3.%E8%AE%A4%E8%AF%86ELF%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E4%B8%80.md">3.认识ELF文件格式一</a></li><li><a href="/%E9%A1%B9%E7%9B%AE/%E9%93%BE%E6%8E%A5%E4%B8%8E%E8%A3%85%E8%BD%BD/4.%E8%AE%A4%E8%AF%86ELF%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E4%BA%8C.md">4.认识ELF文件格式二</a></li><li><a href="/%E9%A1%B9%E7%9B%AE/%E9%93%BE%E6%8E%A5%E4%B8%8E%E8%A3%85%E8%BD%BD/5.%E8%AE%A4%E8%AF%86ELF%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E4%B8%89.md">5.认识ELF文件格式三</a></li><li><a href="/%E9%A1%B9%E7%9B%AE/%E9%93%BE%E6%8E%A5%E4%B8%8E%E8%A3%85%E8%BD%BD/6.%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5.md">6.静态链接</a></li><li><a href="/%E9%A1%B9%E7%9B%AE/%E9%93%BE%E6%8E%A5%E4%B8%8E%E8%A3%85%E8%BD%BD/7.%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5.md">7.动态链接</a></li><li>[8.PLT hook的实现机制](&#x2F;项目&#x2F;链接与装载&#x2F;8.PLT hook的实现机制.md)</li><li><a href="/%E9%A1%B9%E7%9B%AE/%E9%93%BE%E6%8E%A5%E4%B8%8E%E8%A3%85%E8%BD%BD/image/">image</a></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;/%E9%A1%B9%E7%9B%AE/&quot;&gt;返回上一级 [项目]&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/%E9%A1%B9%E7%9B%AE/%E9%93%BE%E6%8E%A5%E4%B8%8E%E8%A3%85%E8%BD%BD/&quot;</summary>
      
    
    
    
    <category term="项目" scheme="https://noahyzhang.github.io/categories/%E9%A1%B9%E7%9B%AE/"/>
    
    <category term="链接与装载" scheme="https://noahyzhang.github.io/categories/%E9%A1%B9%E7%9B%AE/%E9%93%BE%E6%8E%A5%E4%B8%8E%E8%A3%85%E8%BD%BD/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://noahyzhang.github.io/2023/10/21/%E9%A1%B9%E7%9B%AE/%E9%94%81%E7%AB%9E%E4%BA%89%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/README/"/>
    <id>https://noahyzhang.github.io/2023/10/21/%E9%A1%B9%E7%9B%AE/%E9%94%81%E7%AB%9E%E4%BA%89%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/README/</id>
    <published>2023-10-21T14:22:16.752Z</published>
    <updated>2023-10-21T14:22:16.752Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="/%E9%A1%B9%E7%9B%AE/">返回上一级 [项目]</a></li><li><a href="/%E9%A1%B9%E7%9B%AE/%E9%94%81%E7%AB%9E%E4%BA%89%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/">锁竞争分析工具</a><ul><li><a href="/%E9%A1%B9%E7%9B%AE/%E9%94%81%E7%AB%9E%E4%BA%89%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/image/">image</a></li><li><a href="/%E9%A1%B9%E7%9B%AE/%E9%94%81%E7%AB%9E%E4%BA%89%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/%E5%8E%9F%E7%90%86.md">原理</a></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;/%E9%A1%B9%E7%9B%AE/&quot;&gt;返回上一级 [项目]&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/%E9%A1%B9%E7%9B%AE/%E9%94%81%E7%AB%9E%E4%BA%89%E5%88%86%E6%9E%90%E</summary>
      
    
    
    
    <category term="项目" scheme="https://noahyzhang.github.io/categories/%E9%A1%B9%E7%9B%AE/"/>
    
    <category term="锁竞争分析工具" scheme="https://noahyzhang.github.io/categories/%E9%A1%B9%E7%9B%AE/%E9%94%81%E7%AB%9E%E4%BA%89%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://noahyzhang.github.io/2023/10/21/%E9%A1%B9%E7%9B%AE/%E9%94%81%E7%AB%9E%E4%BA%89%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/image/README/"/>
    <id>https://noahyzhang.github.io/2023/10/21/%E9%A1%B9%E7%9B%AE/%E9%94%81%E7%AB%9E%E4%BA%89%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/image/README/</id>
    <published>2023-10-21T14:22:16.752Z</published>
    <updated>2023-10-21T14:22:16.752Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="/%E9%A1%B9%E7%9B%AE/%E9%94%81%E7%AB%9E%E4%BA%89%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/">返回上一级 [锁竞争分析工具]</a></li><li><a href="/%E9%A1%B9%E7%9B%AE/%E9%94%81%E7%AB%9E%E4%BA%89%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/image/">image</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;/%E9%A1%B9%E7%9B%AE/%E9%94%81%E7%AB%9E%E4%BA%89%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/&quot;&gt;返回上一级 [锁竞争分析工具]&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href</summary>
      
    
    
    
    <category term="项目" scheme="https://noahyzhang.github.io/categories/%E9%A1%B9%E7%9B%AE/"/>
    
    <category term="锁竞争分析工具" scheme="https://noahyzhang.github.io/categories/%E9%A1%B9%E7%9B%AE/%E9%94%81%E7%AB%9E%E4%BA%89%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/"/>
    
    <category term="image" scheme="https://noahyzhang.github.io/categories/%E9%A1%B9%E7%9B%AE/%E9%94%81%E7%AB%9E%E4%BA%89%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/image/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://noahyzhang.github.io/2023/10/21/%E9%A1%B9%E7%9B%AE/%E9%93%BE%E6%8E%A5%E4%B8%8E%E8%A3%85%E8%BD%BD/image/README/"/>
    <id>https://noahyzhang.github.io/2023/10/21/%E9%A1%B9%E7%9B%AE/%E9%93%BE%E6%8E%A5%E4%B8%8E%E8%A3%85%E8%BD%BD/image/README/</id>
    <published>2023-10-21T14:22:16.752Z</published>
    <updated>2023-10-21T14:22:16.752Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="/%E9%A1%B9%E7%9B%AE/%E9%93%BE%E6%8E%A5%E4%B8%8E%E8%A3%85%E8%BD%BD/">返回上一级 [链接与装载]</a></li><li><a href="/%E9%A1%B9%E7%9B%AE/%E9%93%BE%E6%8E%A5%E4%B8%8E%E8%A3%85%E8%BD%BD/image/">image</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;/%E9%A1%B9%E7%9B%AE/%E9%93%BE%E6%8E%A5%E4%B8%8E%E8%A3%85%E8%BD%BD/&quot;&gt;返回上一级 [链接与装载]&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/%E9%A1%B9%E7%9B%A</summary>
      
    
    
    
    <category term="项目" scheme="https://noahyzhang.github.io/categories/%E9%A1%B9%E7%9B%AE/"/>
    
    <category term="链接与装载" scheme="https://noahyzhang.github.io/categories/%E9%A1%B9%E7%9B%AE/%E9%93%BE%E6%8E%A5%E4%B8%8E%E8%A3%85%E8%BD%BD/"/>
    
    <category term="image" scheme="https://noahyzhang.github.io/categories/%E9%A1%B9%E7%9B%AE/%E9%93%BE%E6%8E%A5%E4%B8%8E%E8%A3%85%E8%BD%BD/image/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://noahyzhang.github.io/2023/10/21/%E9%A1%B9%E7%9B%AE/%E8%BF%90%E8%A1%8C%E5%BA%93/README/"/>
    <id>https://noahyzhang.github.io/2023/10/21/%E9%A1%B9%E7%9B%AE/%E8%BF%90%E8%A1%8C%E5%BA%93/README/</id>
    <published>2023-10-21T14:22:16.751Z</published>
    <updated>2023-10-21T14:22:16.751Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="/%E9%A1%B9%E7%9B%AE/">返回上一级 [项目]</a></li><li><a href="/%E9%A1%B9%E7%9B%AE/%E8%BF%90%E8%A1%8C%E5%BA%93/">运行库</a><ul><li><a href="/%E9%A1%B9%E7%9B%AE/%E8%BF%90%E8%A1%8C%E5%BA%93/1.%E6%A0%88%E4%B8%8E%E8%B0%83%E7%94%A8%E6%83%AF%E4%BE%8B.md">1.栈与调用惯例</a></li><li><a href="/%E9%A1%B9%E7%9B%AE/%E8%BF%90%E8%A1%8C%E5%BA%93/image/">image</a></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;/%E9%A1%B9%E7%9B%AE/&quot;&gt;返回上一级 [项目]&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/%E9%A1%B9%E7%9B%AE/%E8%BF%90%E8%A1%8C%E5%BA%93/&quot;&gt;运行库&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;</summary>
      
    
    
    
    <category term="项目" scheme="https://noahyzhang.github.io/categories/%E9%A1%B9%E7%9B%AE/"/>
    
    <category term="运行库" scheme="https://noahyzhang.github.io/categories/%E9%A1%B9%E7%9B%AE/%E8%BF%90%E8%A1%8C%E5%BA%93/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://noahyzhang.github.io/2023/10/21/%E9%A1%B9%E7%9B%AE/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%98%9F%E5%88%97/README/"/>
    <id>https://noahyzhang.github.io/2023/10/21/%E9%A1%B9%E7%9B%AE/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%98%9F%E5%88%97/README/</id>
    <published>2023-10-21T14:22:16.751Z</published>
    <updated>2023-10-21T14:22:16.751Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="/%E9%A1%B9%E7%9B%AE/">返回上一级 [项目]</a></li><li><a href="/%E9%A1%B9%E7%9B%AE/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%98%9F%E5%88%97/">线程安全队列</a><ul><li><a href="/%E9%A1%B9%E7%9B%AE/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%98%9F%E5%88%97/%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97.md">无锁队列</a></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;/%E9%A1%B9%E7%9B%AE/&quot;&gt;返回上一级 [项目]&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/%E9%A1%B9%E7%9B%AE/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%98%9F%E</summary>
      
    
    
    
    <category term="项目" scheme="https://noahyzhang.github.io/categories/%E9%A1%B9%E7%9B%AE/"/>
    
    <category term="线程安全队列" scheme="https://noahyzhang.github.io/categories/%E9%A1%B9%E7%9B%AE/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%98%9F%E5%88%97/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://noahyzhang.github.io/2023/10/21/%E9%A1%B9%E7%9B%AE/%E6%89%8B%E5%86%99%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F%E4%BA%A4%E4%BA%92/README/"/>
    <id>https://noahyzhang.github.io/2023/10/21/%E9%A1%B9%E7%9B%AE/%E6%89%8B%E5%86%99%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F%E4%BA%A4%E4%BA%92/README/</id>
    <published>2023-10-21T14:22:16.751Z</published>
    <updated>2023-10-21T14:22:16.751Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="/%E9%A1%B9%E7%9B%AE/%E6%89%8B%E5%86%99%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">返回上一级 [手写操作系统]</a></li><li><a href="/%E9%A1%B9%E7%9B%AE/%E6%89%8B%E5%86%99%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F%E4%BA%A4%E4%BA%92/">系统交互</a><ul><li><a href="/%E9%A1%B9%E7%9B%AE/%E6%89%8B%E5%86%99%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F%E4%BA%A4%E4%BA%92/1.%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%A6%82%E5%BF%B5.md">1.系统调用概念</a></li><li><a href="/%E9%A1%B9%E7%9B%AE/%E6%89%8B%E5%86%99%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F%E4%BA%A4%E4%BA%92/2.fork%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E5%AE%9E%E7%8E%B0.md">2.fork的原理和实现</a></li><li><a href="/%E9%A1%B9%E7%9B%AE/%E6%89%8B%E5%86%99%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F%E4%BA%A4%E4%BA%92/3.wait%E5%92%8Cexit%E7%9A%84%E5%8E%9F%E7%90%86.md">3.wait和exit的原理</a></li><li><a href="/%E9%A1%B9%E7%9B%AE/%E6%89%8B%E5%86%99%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F%E4%BA%A4%E4%BA%92/4.%E7%AE%A1%E9%81%93.md">4.管道</a></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;/%E9%A1%B9%E7%9B%AE/%E6%89%8B%E5%86%99%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/&quot;&gt;返回上一级 [手写操作系统]&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/%E9%A1%</summary>
      
    
    
    
    <category term="项目" scheme="https://noahyzhang.github.io/categories/%E9%A1%B9%E7%9B%AE/"/>
    
    <category term="手写操作系统" scheme="https://noahyzhang.github.io/categories/%E9%A1%B9%E7%9B%AE/%E6%89%8B%E5%86%99%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="系统交互" scheme="https://noahyzhang.github.io/categories/%E9%A1%B9%E7%9B%AE/%E6%89%8B%E5%86%99%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F%E4%BA%A4%E4%BA%92/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://noahyzhang.github.io/2023/10/21/%E9%A1%B9%E7%9B%AE/%E6%89%8B%E5%86%99%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/README/"/>
    <id>https://noahyzhang.github.io/2023/10/21/%E9%A1%B9%E7%9B%AE/%E6%89%8B%E5%86%99%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/README/</id>
    <published>2023-10-21T14:22:16.751Z</published>
    <updated>2023-10-21T14:22:16.751Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="/%E9%A1%B9%E7%9B%AE/%E6%89%8B%E5%86%99%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">返回上一级 [手写操作系统]</a></li><li><a href="/%E9%A1%B9%E7%9B%AE/%E6%89%8B%E5%86%99%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/">进程和线程</a><ul><li><a href="/%E9%A1%B9%E7%9B%AE/%E6%89%8B%E5%86%99%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/1.%E6%A6%82%E5%BF%B5.md">1.概念</a></li><li><a href="/%E9%A1%B9%E7%9B%AE/%E6%89%8B%E5%86%99%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/2.%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E5%BC%8F.md">2.实现线程的方式</a></li><li><a href="/%E9%A1%B9%E7%9B%AE/%E6%89%8B%E5%86%99%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/3.%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%B0%83%E5%BA%A6.md">3.多线程调度</a></li><li><a href="/%E9%A1%B9%E7%9B%AE/%E6%89%8B%E5%86%99%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/4.%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0.md">4.线程实现</a></li><li><a href="/%E9%A1%B9%E7%9B%AE/%E6%89%8B%E5%86%99%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/5.%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F.md">5.进程的实现方式</a></li><li><a href="/%E9%A1%B9%E7%9B%AE/%E6%89%8B%E5%86%99%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/6.%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F.md">6.协程的实现方式</a></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;/%E9%A1%B9%E7%9B%AE/%E6%89%8B%E5%86%99%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/&quot;&gt;返回上一级 [手写操作系统]&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/%E9%A1%</summary>
      
    
    
    
    <category term="项目" scheme="https://noahyzhang.github.io/categories/%E9%A1%B9%E7%9B%AE/"/>
    
    <category term="手写操作系统" scheme="https://noahyzhang.github.io/categories/%E9%A1%B9%E7%9B%AE/%E6%89%8B%E5%86%99%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="进程和线程" scheme="https://noahyzhang.github.io/categories/%E9%A1%B9%E7%9B%AE/%E6%89%8B%E5%86%99%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://noahyzhang.github.io/2023/10/21/%E9%A1%B9%E7%9B%AE/%E8%BF%90%E8%A1%8C%E5%BA%93/image/README/"/>
    <id>https://noahyzhang.github.io/2023/10/21/%E9%A1%B9%E7%9B%AE/%E8%BF%90%E8%A1%8C%E5%BA%93/image/README/</id>
    <published>2023-10-21T14:22:16.751Z</published>
    <updated>2023-10-21T14:22:16.751Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="/%E9%A1%B9%E7%9B%AE/%E8%BF%90%E8%A1%8C%E5%BA%93/">返回上一级 [运行库]</a></li><li><a href="/%E9%A1%B9%E7%9B%AE/%E8%BF%90%E8%A1%8C%E5%BA%93/image/">image</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;/%E9%A1%B9%E7%9B%AE/%E8%BF%90%E8%A1%8C%E5%BA%93/&quot;&gt;返回上一级 [运行库]&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/%E9%A1%B9%E7%9B%AE/%E8%BF%90%E8%A1%8C</summary>
      
    
    
    
    <category term="项目" scheme="https://noahyzhang.github.io/categories/%E9%A1%B9%E7%9B%AE/"/>
    
    <category term="运行库" scheme="https://noahyzhang.github.io/categories/%E9%A1%B9%E7%9B%AE/%E8%BF%90%E8%A1%8C%E5%BA%93/"/>
    
    <category term="image" scheme="https://noahyzhang.github.io/categories/%E9%A1%B9%E7%9B%AE/%E8%BF%90%E8%A1%8C%E5%BA%93/image/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://noahyzhang.github.io/2023/10/21/%E9%A1%B9%E7%9B%AE/%E6%89%8B%E5%86%99%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%A1%AC%E7%9B%98/README/"/>
    <id>https://noahyzhang.github.io/2023/10/21/%E9%A1%B9%E7%9B%AE/%E6%89%8B%E5%86%99%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%A1%AC%E7%9B%98/README/</id>
    <published>2023-10-21T14:22:16.751Z</published>
    <updated>2023-10-21T14:22:16.751Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="/%E9%A1%B9%E7%9B%AE/%E6%89%8B%E5%86%99%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">返回上一级 [手写操作系统]</a></li><li><a href="/%E9%A1%B9%E7%9B%AE/%E6%89%8B%E5%86%99%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%A1%AC%E7%9B%98/">硬盘</a><ul><li><a href="/%E9%A1%B9%E7%9B%AE/%E6%89%8B%E5%86%99%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%A1%AC%E7%9B%98/1.%E7%A1%AC%E7%9B%98%E5%88%86%E5%8C%BA%E5%8E%9F%E7%90%86.md">1.硬盘分区原理</a></li><li><a href="/%E9%A1%B9%E7%9B%AE/%E6%89%8B%E5%86%99%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%A1%AC%E7%9B%98/2.%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.md">2.文件系统原理</a></li><li><a href="/%E9%A1%B9%E7%9B%AE/%E6%89%8B%E5%86%99%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%A1%AC%E7%9B%98/3.%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%862.md">3.文件系统原理2</a></li><li><a href="/%E9%A1%B9%E7%9B%AE/%E6%89%8B%E5%86%99%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%A1%AC%E7%9B%98/4.%E7%A1%AC%E7%9B%98%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F.md">4.硬盘驱动程序</a></li><li><a href="/%E9%A1%B9%E7%9B%AE/%E6%89%8B%E5%86%99%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%A1%AC%E7%9B%98/5.%E6%93%8D%E4%BD%9C%E7%A1%AC%E7%9B%98.md">5.操作硬盘</a></li><li><a href="/%E9%A1%B9%E7%9B%AE/%E6%89%8B%E5%86%99%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%A1%AC%E7%9B%98/6.%E6%89%93%E5%8D%B0%E5%87%BD%E6%95%B0.md">6.打印函数</a></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;/%E9%A1%B9%E7%9B%AE/%E6%89%8B%E5%86%99%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/&quot;&gt;返回上一级 [手写操作系统]&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/%E9%A1%</summary>
      
    
    
    
    <category term="项目" scheme="https://noahyzhang.github.io/categories/%E9%A1%B9%E7%9B%AE/"/>
    
    <category term="手写操作系统" scheme="https://noahyzhang.github.io/categories/%E9%A1%B9%E7%9B%AE/%E6%89%8B%E5%86%99%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="硬盘" scheme="https://noahyzhang.github.io/categories/%E9%A1%B9%E7%9B%AE/%E6%89%8B%E5%86%99%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%A1%AC%E7%9B%98/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://noahyzhang.github.io/2023/10/21/%E9%A1%B9%E7%9B%AE/%E6%89%8B%E5%86%99%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%85%B6%E4%BB%96/README/"/>
    <id>https://noahyzhang.github.io/2023/10/21/%E9%A1%B9%E7%9B%AE/%E6%89%8B%E5%86%99%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%85%B6%E4%BB%96/README/</id>
    <published>2023-10-21T14:22:16.750Z</published>
    <updated>2023-10-21T14:22:16.750Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="/%E9%A1%B9%E7%9B%AE/%E6%89%8B%E5%86%99%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">返回上一级 [手写操作系统]</a></li><li><a href="/%E9%A1%B9%E7%9B%AE/%E6%89%8B%E5%86%99%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%85%B6%E4%BB%96/">其他</a><ul><li><a href="/%E9%A1%B9%E7%9B%AE/%E6%89%8B%E5%86%99%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%85%B6%E4%BB%96/%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%E4%B9%8B%E9%94%81.md">同步机制之锁</a></li><li><a href="/%E9%A1%B9%E7%9B%AE/%E6%89%8B%E5%86%99%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%85%B6%E4%BB%96/%E7%AC%94%E8%AE%B0.md">笔记</a></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;/%E9%A1%B9%E7%9B%AE/%E6%89%8B%E5%86%99%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/&quot;&gt;返回上一级 [手写操作系统]&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/%E9%A1%</summary>
      
    
    
    
    <category term="项目" scheme="https://noahyzhang.github.io/categories/%E9%A1%B9%E7%9B%AE/"/>
    
    <category term="手写操作系统" scheme="https://noahyzhang.github.io/categories/%E9%A1%B9%E7%9B%AE/%E6%89%8B%E5%86%99%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="其他" scheme="https://noahyzhang.github.io/categories/%E9%A1%B9%E7%9B%AE/%E6%89%8B%E5%86%99%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%85%B6%E4%BB%96/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://noahyzhang.github.io/2023/10/21/%E9%A1%B9%E7%9B%AE/%E6%89%8B%E5%86%99%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/README/"/>
    <id>https://noahyzhang.github.io/2023/10/21/%E9%A1%B9%E7%9B%AE/%E6%89%8B%E5%86%99%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/README/</id>
    <published>2023-10-21T14:22:16.750Z</published>
    <updated>2023-10-21T14:22:16.750Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="/%E9%A1%B9%E7%9B%AE/%E6%89%8B%E5%86%99%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">返回上一级 [手写操作系统]</a></li><li><a href="/%E9%A1%B9%E7%9B%AE/%E6%89%8B%E5%86%99%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/">保护模式</a><ul><li><a href="/%E9%A1%B9%E7%9B%AE/%E6%89%8B%E5%86%99%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/1.%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.md">1.保护模式</a></li><li><a href="/%E9%A1%B9%E7%9B%AE/%E6%89%8B%E5%86%99%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/2.%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F2.md">2.保护模式2</a></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;/%E9%A1%B9%E7%9B%AE/%E6%89%8B%E5%86%99%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/&quot;&gt;返回上一级 [手写操作系统]&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/%E9%A1%</summary>
      
    
    
    
    <category term="项目" scheme="https://noahyzhang.github.io/categories/%E9%A1%B9%E7%9B%AE/"/>
    
    <category term="手写操作系统" scheme="https://noahyzhang.github.io/categories/%E9%A1%B9%E7%9B%AE/%E6%89%8B%E5%86%99%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="保护模式" scheme="https://noahyzhang.github.io/categories/%E9%A1%B9%E7%9B%AE/%E6%89%8B%E5%86%99%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
</feed>
